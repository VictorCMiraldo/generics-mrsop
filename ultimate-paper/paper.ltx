%% For double-blind review submission, w/ CCS and ACM Reference
\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true}

\newenvironment{myhs}{\par\vspace{0.15cm}\begin{minipage}{\textwidth}}{\end{minipage}\vspace{0.15cm}}

%include lhs2TeX.fmt
%include lhs2TeX.sty
%include custom.fmt

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{cleveref}

\begin{document}

%% Title information
\title{Generic Programming of All Kinds}
\subtitle{A Tribute to Haskell's Power}

\author{Alejandro Serrano}
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Junior lecturer}
  \department{Information and Computing Sciences}
  \institution{Utrecht University}
  \streetaddress{Princetonplein, 5}
  \city{Utrecht}
  \state{Utrecht}
  \postcode{3584 CC}
  \country{The Netherlands} 
}
\email{A.SerranoMena@@uu.nl}

\author{Victor Cacciari Miraldo}
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{PhD candidate}
  \department{Information and Computing Sciences}
  \institution{Utrecht University}
  \streetaddress{Princetonplein, 5}
  \city{Utrecht}
  \state{Utrecht}
  \postcode{3584 CC}
  \country{The Netherlands} 
}
\email{V.CacciariMiraldo@@uu.nl}


\begin{abstract}
Lots of nice ideas here \\
Line 2 \\
Line 3 \\
Line 4 \\
Line 5 \\
Line 6 \\
Line 7 \\
Line 8
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
%% End of generated code

\keywords{Generic programming, Haskell}

\maketitle


\section{Introduction}

(Datatype)-generic programming is a powerful tool to define functions by induction over the structure of a datatype. Simpler mechanisms, such as the |deriving| clause, have been present in Haskell for a long time \cite{haskell2010}, although restricted to a few generic operation such as equality. Over the years, many different approaches have been described to allow the definition of generic functions by the programmer (see~\cite{Rodriguez2008,Magalhaes2012} for a comparison). Ultimately, GHC added special support via the |Data|~\cite{Lammel2003,Mitchell2007} and |Generic|~\cite{Magalhaes2010} type classes.

There is a general idea behind the strand of work to which |Generic| belongs: if we represent the shape of each datatype as type-level information, then we can use type-level techniques to define the generic operations. Libraries differ in the primitive building blocks for those shapes, and in how these shapes are encoded. For example, |Generic| uses the following functors as building blocks:
\begin{myhs}
\begin{code}
data V1           p                           -- empty
data U1           p = U1                      -- unit
data K1 i c       p = K1 c                    -- constant
data (f  :+:  g)  p = L1 (f p) | R1 (g p)     -- sum
data (f  :*:  g)  p = (f p) :*: (g p)         -- product
data M1 i c f     p = M1 (f p)                -- metadata
\end{code}
\end{myhs}
By combining these blocks we can describe the structure of any algebraic datatype. We encode the choice of constructors by sums, and the combination of fields of a constructor by products, or by the unit functor if there are none. In turn, each field is represented by a constant functor. To make things more concrete, here is a definition for binary trees:
\begin{myhs}
\begin{code}
data Tree a = Leaf | Node (Tree a) a (Tree a)
\end{code}
\end{myhs}
The shape of this datatype is described by the following functor. For the sake of conciseness, we omit the additional information such as the name of constructors and fields, which would be present as metadata via the |M1| functor.
\begin{myhs}
\begin{code}
U1 :+: (K1 R (Tree a) :*: K1 R a :*: K1 R (Tree a))
\end{code}
\end{myhs}
We say that the type above is the \emph{representation} of |Tree a|. In order to use generic operations, we must tie each datatype with its representation, this is done via the |Generic| type class. In addition, we ought to witness the isomorphism at the term level via a pair of functions |to| and |from|.
\begin{myhs}
\begin{code}
class Generic a where
  type Rep a :: * -> *
  from  :: a -> Rep a p
  to    :: Rep a p -> a
\end{code}
\end{myhs}
Fortunately, we do not have to write |Generic| instances by hand. GHC provides an extension to the |deriving| mechanism to create these instances. In fact, all generic programming libraries automate this step, making use of metaprogramming facilities such as Template Haskell~\cite{Sheard2002}.

\subsection{Contributions}

The |Generic| type class defined above only allows to represent ground types, in other words, types which kind |Star|. But this is not enough for all our purposes. For example, if we want to give a generic |fmap| definition, we need to know the structure of a type constructor of kind |Star -> Star| instead. Some libraries provide ad-hoc |Generic1| classes for that single purpose.

The main contribution of this paper is to provide a \emph{single, unified} type class for generic programming over types of all kinds (\Cref{sec:allkinds}). We do so by using a variant of the sum-of-products representation with explicit fixpoints, notions which we explore in \Cref{sec:pre}.

Representing arbitrary constructor moves us a step forward to being able to accurately represent the shape of \emph{every} Haskell datatype. Since the introduction of Generalised Algebraic Data Types~\cite{Xi2003}, we need to additional combinators to make that dream true:
\begin{itemize}
\item Each constructor may require one or more \emph{constraints} to be satisfied by the types of their fields. For example, when we write a datatype to witness the equality between two types:
\begin{myhs}
\begin{code}
class Eql a b where
  Refl :: a ~ b => Eql a b
\end{code}
\end{myhs}
we require the indices of |Eql|, namely |a| and |b|, to be equal. This is represented by the constraint |a ~ b| in the |Refl| constructor.

In \Cref{sec:constraints} we explore how to extend our base framework to account for constraints.

\item Constructor may also mention type variables which are not reflected in the indices. These are called \emph{existentials}, since once you pattern match you know that a type has been used, but not exactly which one.

As we shall see in \Cref{sec:exists}, it is possible to describe datatypes with existentials in the type level, but unfortunately not possible to represent them at the term level. For that functionality we require real dependent types, as provided by Agda.
\end{itemize}

This paper also aims to witness how far the type level facilities in GHC have evolved. None of the contributions in this paper would be possible without datatype promotion, kind polymorphism ~\cite{Yorgey2012}, the |Constraint| kind~\cite{constraintkinds}, or the |TypeInType| extension~\cite{Weirich2013,Weirich2017}.

\section{Preliminaries}
\label{sec:pre}

Before exploring the novel ideas in the paper, we need to recap some notions from the current landscape of generic programming in GHC. As in the Introduction, we focus on the |Generic| line of work.

\subsection{Generic operations}

In order to define an operation generically, we create two dedicated \emph{type classes}, one for ground types and one for type constructors. A simple generic operation is |size|, which counts the number of constructors.
\begin{myhs}
\begin{code}
class Size a where
  size   ::   a    -> Integer

class GSize f where
  gsize  ::   f p  -> Integer
\end{code}
\end{myhs}
We then write instances of the second class for each of the building blocks of datatypes. The type class mechanism is how we reflect the type level structure into a term level implementation.
\begin{myhs}
\begin{code}
instance (GSize f , GSize g) => GSize (f :*: g) where
  gsize (f :*: g)  = gsize f + gsize g
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
instance (GSize f , GSize g) => GSize (f :+: g) where
  gsize (L1 f)     = gsize f
  gsize (R1 g)     = gsize g
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
instance (Size c) => GSize (K1 i c) where
  gsize (K1 x)     = size x
\end{code}
\end{myhs}
Note how the instance of constants |K1| points back to the type class for ground types, |Size|. We need one such instance for each datatype; but now we can reuse the generic implementation if we first transform the value into its representation.
\begin{myhs}
\begin{code}
instance Size Int where
  size n = 1

instance Size (Tree a) where
  size t = gsize (from t)
\end{code}
\end{myhs}
The definition of |size| is very simple, other generic operations such as |show| or |parse| need to access the metadata and keep additional information around.

\subsection{Sums of Products}

Algebraic datatypes in Haskell have a very regular shape when represented using the building blocks above. There is always a choice among several constructor, each of them comprised of zero or more fields. This general structure is called a \emph{sum of products}. Unfortunately, the representation using |Generic| is not strong enough to guarantee that shape; there is nothing forbidding us from writing:
\begin{myhs}
\begin{code}
U1 :+: (K1 R Int :*: Maybe)
\end{code}
\end{myhs}

The landscape of type-level programming in GHC changed radically after the introduction of \emph{datatype promotion}~\cite{Yorgey2012}. By promoting a datatype you can use its constructors as if they were types, and the type being defined is promoted to a kind. For example, we can use a promoted Boolean value to encode whether a certain string has been validated or not.
\begin{myhs}
\begin{code}
data VString (v :: Bool) = VString String

validate :: VString False -> VString True
\end{code}
\end{myhs}

The \texttt{generic-sop} library~\cite{deVries2014} uses this facility to guarantee the sum-of-products invariants. Each datatype is described by a list of list of types, where the outer level should be thought as the choice between constructors, and each inner list represents the fields in that constructor. This description is called the \emph{code} of the datatype. For example, here is the code for |Tree a| defined above:\footnote{The quote sign serves to differentiate type level from term level when there is a risk of confusion.}
\begin{myhs}
\begin{code}
P [ P [], P [Tree a, a, Tree a]]
\end{code}
\end{myhs}
But now another problem arises: we cannot construct terms of the code directly, we first need to turn it into a ground type. The kind of the type level list is |[[Star]]| -- where |Star| is the kind of ground types in Haskell -- whereas we can only write terms of kind |Star|. The bridge between the two worlds is given by the following two GADTs, |NS| interprets a list of elements as a choice, whereas |NP| requires a value for each element in the list, and thus encodes a product.
\begin{myhs}
\begin{code}
data NS :: (k -> Star) -> [k] -> Star where
  Here   :: f k      -> NS f (k (P (:)) ks)
  There  :: NS f ks  -> NS f (k (P (:)) ks)
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
data NP :: (k -> Star) -> [k] -> Star where
  Nil  ::                    NP f (P [])
  (:*) :: f x -> NP f xs ->  NP f (x (P (:)) xs)
\end{code}
\end{myhs}
The first parameter in both |NS| and |NP| indicates how to treat elements of the type level list, by applying a certain constructor to each of them. For the product part we want to use the type as-is, and thus we use the identity functor there,
\begin{myhs}
\begin{code}
data I p = I p
\end{code}
\end{myhs}
whereas for each member of |NS| we want to recursively use |NP|. The ground type representing a certain code |c| is then given by:
\begin{myhs}
\begin{code}
type SOP c = NS (NP I) c
\end{code}
\end{myhs}
As in the case of the built-in |Generic|, each datatype is tied to its code by a type class. In the implementation this class is also known as |Generic|, but we shall use a subscript to distinguish it.
\begin{myhs}
\begin{code}
class GenericSOP a where
  type Code a :: [[Star]]
  from  :: a -> SOP (Code a)
  to    :: SOP (Code a) -> a
\end{code}
\end{myhs}

This approach to generic programming allows the definition of generic operations without resorting to the type class mechanism. By pattern matching on the |NS| and |NP| constructors we gain enough information about the shape of the datatype. For example, here is the definition of the generic |size| operation:
\begin{myhs}
\begin{code}
gsize :: (GenericSOP a, All2 Size (Code a)) => a -> Integer
gsize = goS . from
  where  goS (Here   x)  = goP  x
         goS (There  x)  = goS  x
         goP Nil         = 0
         goP (x :* xs)   = size x + goP xs
\end{code}
\end{myhs}
The only remarkable part of this implementation is the use of the |All2| type class to ensure that every type which appears in a field of the code has a corresponding |size| operation.

\subsection{Explicit Recursion}

Both |Generic| and |GenericSOP| mark recursive positions in the datatype \emph{implicitly}. This means that those fields which mention the datatype being defined are not treated in a different way to the others. You can only notice them as a programmer when you see that the |Rep| or |Code| mention the type itself, as was the case with the |Tree a| datatype from the Introduction.

This is not the only possibility, though. \citet{Noort2008} and \citet{Yakushev2009} extend the |Generic| framework with an additional building block which marks recursive positions.
\begin{myhs}
\begin{code}
data Rec p = Rec p
\end{code}
\end{myhs}
The |Rec| type is isomorphic to the |I| type used to represent codes in the \texttt{generic-sop} approach. The twist now is that in the corresponding |GenericRegular| type class the type for the parameter |p| of the functor is not generic --- as was the case with |Generic| --- but it is instantiated with the type being represented. This ties the recursion by making the |Rec| fields point back to the defined type itself.
\begin{myhs}
\begin{code}
class GenericRegular a where
  type RepRegular a :: * -> *
  from  :: a -> RepRegular a a
  to    :: RepRegular a a -> a
\end{code}
\end{myhs}

The information about the recursive position opens more possibilities for generic operations. For example, we can define the \emph{fixpoint} of a representation, without any mention of the original datatype being represented. This allows us to operate on generic data without carrying around additional baggage about the contained types.
\begin{myhs}
\begin{code}
newtype Fix f = Fix (f (Fix f))
\end{code}
\end{myhs}
Some generic operations which use this explicit recursion information is the definition of diff and patch~\cite{Lempsink2009}, zippers~\cite{Hinze2003}, and tree regular expressions~\cite{Serrano2016}.

\section{Generic Type Constructors}

As we have mentioned in the Contributions, our goal is to encode the shape of datatypes of all possible kinds, not only |Star|. The reason is that many interesting generic operations --- including the well-known |fmap| from |Functor| --- are defined for higher-kinded types. In this section we look at the already-existing support in the |Generic| framework of GHC, and how to translate this idea to the \texttt{generics-sop} framework.

The |Generic1| type class is the counterpart of |Generic| for types with one parameter, such as |Maybe| or |[]|. The definition is pretty similar, except that |from1| and |to1| take as argument an instantiated version |f a| of the type constructor |f|. The same instantiation is done in the generic representation.
\begin{myhs}
\begin{code}
class Generic1 f where
  type Rep1 f :: * -> *
  from1  :: f a -> Rep f a
  to1    :: Rep f a -> f a
\end{code}
\end{myhs}

The bulding blocks from |Generic| need to be extended to mark those places where the type variable occurs. For those occasions in which the variable appears naked, we use |Par1|. It might also be the case that some type constructor is applied to that variable, in which case we use |Rec1|. The definition of these types look very similar to the identity and recursion functions defined previously, but the role in the representation is quite different.
\begin{myhs}
\begin{code}
data Par1    p = Par1 p
data Rec1 f  p = Rec1 (f p)
\end{code}
\end{myhs}
We can now give a representation of the |Tree| type constructor. In contrast, before we had defined a family of representations for |Tree a|, regardless of the |a|.
\begin{myhs}
\begin{code}
U1 :+: (Rec1 Tree :*: Par1 :*: Rec1 Tree)
\end{code}
\end{myhs}

|Rec1| is not powerful enough to represent every sort of recursion in Haskell datatypes. Rose trees are a prime example of \emph{non-regular} recursion, since |Rose a| appears under a list constructor.
\begin{myhs}
\begin{code}
data Rose a = Fork a [Rose a]
\end{code}
\end{myhs}
The solution is to introduce \emph{functor composition} as an additional building block:
\begin{myhs}
\begin{code}
data (f :.: g) a = Comp (f (g a))
\end{code}
\end{myhs}
The second field of |Fork| is described then as the composition of the list constructor, and recursion done via |Rec1|.
\begin{myhs}
\begin{code}
Par1 :*: ([] :.: Rec1 Rose)
\end{code}
\end{myhs}
For the rest of the section we focus on the simplest subset of regular types, although non-regularity can be recovered by introducing explicit functor composition as done here.

Defining generic operations for |Generic1| is done as for |Generic|; one just need to add additional instances for the new |Par1| and |Rec1| functors, and for |f :.: g| if non-regular recursion is allowed. Here are the important pieces of the generic |fmap| declaration, taken from the \texttt{generic-deriving} package. The rest of the instances just apply |gfmap| recursively in every position.
\begin{myhs}
\begin{code}
class GFunctor f where
  gmap :: (a -> b) -> f a -> f b

instance GFunctor Par1 where
  gmap f (Par1 a)  = Par1 (f a)
instance (Functor f) => GFunctor (Rec1 f) where
  gmap f (Rec1 a)  = Rec1 (fmap f a)
instance (Functor f, GFunctor g)
  => GFunctor (f :.: g) where
  gmap f (Comp x)  = Comp (fmap (gmap f) x)
\end{code}
\end{myhs}

The main problem of |Generic1| is that the building blocks do not scale to more than one parameter. At the very least, we would need new |Par1| and |Par2| types which refer to each of the type variables.
\begin{myhs}
\begin{code}
data Par1  a b = Par1  a
data Par2  a b = Par2  b
\end{code}
\end{myhs}
By doing so, the kind of the representation can no longer be |Star -> Star|, we need at least |Star -> Star -> Star| to accomodate the two type parameter. Unfortunately, this means that none of |V1|, |U1|, |(:+:)|, and |(:*:)| can be used, since they all create or operate on types of kind |Star -> Star|. We could build a completely different set of primitive building blocks for two-parameter types, but the problem would repeat again once we consider three parameters.

\subsection{|Generic1| in \texttt{generics-sop}}

The key point to extend a generic framework to handle type constructors is to introduce marks for those places where the type parameter ought to appear. In the case of |Generic1|, it was only a matter of adding new |Par1| and |Rec1| types.

The approach taken by \texttt{generics-sop} is to describe a datatype by a list of list of types. Ultimately, the elements of the nested lists are ground types, of kind |Star|. This precludes us from using the same form of codes directly, since we cannot add an indicators for variables or recursion. Instead, we introduce \emph{atoms}, which describe the choice we have for each of our fields:
\begin{myhs}
\begin{code}
data Atom = Var | Rec (Star -> Star) | Kon (Star)
\end{code}
\end{myhs}
A code is no longer represented by |[[Star]]|, but rather |[[Atom]]|. The |NS| and |NP| types which interpret those codes are still valid; the nested list structure is still there. But we also need to interpret each of the atoms into a value of kind |Star|. For that we introduce yet another layer, which we call |NA|:
\begin{myhs}
\begin{code}
data NA :: Star -> Atom -> Star where
  V :: a    -> NA a Var
  R :: f a  -> NA a (Rec f)
  K :: k    -> NA a (Kon k)
\end{code}
\end{myhs}
Each of the constructors in |NA| closely matches the definition of |Par1|, |Rec1|, and |K1| in the |Generic1| framework. The code for our running example, |Tree|, reads as follows:
\begin{myhs}
\begin{code}
P [ P [], P [ Rec Tree, Var, Rec Tree ] ]
\end{code}
\end{myhs}

The last piece is the new |Generic1SOP| type class which ties each datatype to its code. We also define a |SOP1| type synonym for the nested application of the interpretation functors |NS|, |NP|, and |NA|:
\begin{myhs}
\begin{code}
type SOP1 c a = NS (NP (NA a)) c

class Generic1SOP (f :: * -> *) where
  type Code1 f :: [[Atom]]
  from1  :: f a -> SOP1 (Code1 f) a
  to1    :: SOP1 (Code1 f) a -> f a
\end{code}
\end{myhs}
Up to this point we have omitted the implementation of the functions which witness the isomorphism between a regular datatype and its generic representation. It is instructive to consider how it looks for the case of |Tree| takes as a type constructor:
\begin{myhs}
\begin{code}
instance Generic1SOP Tree where
  ...
  from Leaf =  Here    Nil
  from (Node l x r)
    = There $  Here $  R l :* V x :* R r :* Nil
\end{code}
\end{myhs}
After a sequence of |There| and |Here| which indicate which constructor we are working with, we find a |(:*)|-separated list of fields, finished by |Nil|. In each case we need to mark whether that field arises from recursion (with |R|), for an ocurrence of the type parameter (with |V|), or simply from a constant type (with |K|, not shown in this example).

\begin{figure}
\begin{myhs}
\begin{code}
gfmap  ::  (Generic1SOP f, All2 (OnRec Functor) (Code1 f))
       =>  (a -> b) -> f a -> f b
gfmap f = to . goS . from
  where
    goS (Here   x) = Here   (goP x)
    goS (There  x) = There  (goS x)

    goP Nil        = Nil
    goP (x :* xs)  = goA x :* goP xs

    goA (V a) = V (f a)
    goA (R x) = R (fmap f x)
    goA (K k) = K k


class OnRec (c :: (* -> *) -> Constraint) (a :: Atom)
instance c f => OnRec c (Rec f)
instance OnRec c Var
instance OnRec c (Kon k)
\end{code}
\end{myhs}
\caption{Idealized |fmap| using |Generic1SOP|}
\label{fig:gfmap}
\end{figure}

\begin{figure}
\begin{myhs}
\begin{code}
gfmap  ::  forall f a b dot
           (Generic1SOP f, AllRec2 Functor (Code1 f))
       =>  (a -> b) -> f a -> f b
gfmap f = to . goS . from
  where
    goS  ::  AllRec2 Functor xs
         =>  NS (NP (NA a)) xs -> NS (NP (NA b)) xs
    goS (Here   x) = Here   (goP x)
    goS (There  x) = There  (goS x)
        
    goP  ::  AllRec Functor xs
         =>  NP (NA a) xs -> NP (NA b) xs
    goP Nil          = Nil
    goP (R x :* xs)  = (R $ fmap f x)  :* goP xs
    goP (V x :* xs)  = V (f x)         :* goP xs
    goP (K x :* xs)  = K x             :* goP xs

type family AllRec2 c xs :: Constraint where
  AllRec2 c (P [])          = ()
  AllRec2 c (x (P (:)) xs)  = (AllRec c x, AllRec2 c xs)

type family AllRec c xs :: Constraint where
  AllRec c (P [])               = ()
  AllRec c (Rec x  (P (:)) xs)  = (c x, AllRec c xs)
  AllRec c (x      (P (:)) xs)  = AllRec c xs
\end{code}
\end{myhs}
\caption{Working |fmap| using |Generic1SOP|}
\label{fig:gfmap2}
\end{figure}

Armed with our new |Generic1SOP|, we can implement a generic version of |fmap|. Our first attempt is the idealized version in \Cref{fig:gfmap}. As in the case of |GenericSOP|, we use |All2| to ensure that a certain constraint is satisfied by all atoms. Since our constraints only affect |Rec| positions, we define a combinator |OnRec| which only checks a constraint if the atom has the right shape.

Alas, that definition is not accepted directly by GHC, at least in version 8.4.1. First of all, the types involved in the ancillary definitions |goS|, |goP|, and |goA| are too complex to be inferred. We need to help the compiler by annotating the local declarations. We also used the |ScopedTypeVariables| extension to ensure that |f|, |a|, and |b| refer uniformly to the same variables in the code.

The combination of the type family |All2| with the constraint |OnRec Functor|, which is refined depending on the type of atom we are pattern matching over, is too complex for the type checker. The solution is to define a more specific |AllRec2| type family, which only applies the constraint over |Rec| positions. We also need to merge the matching on |goP| and |goA| to mimic the definition of |AllRec2|, otherwise the compiler is not able to check that all the pieces come together in the right place. The resulting, \emph{working}, code is given in \Cref{fig:gfmap2}.

\subsection{More Than One Type Parameter}

It seems that the work put on bringing |Generic1| into the \texttt{generic-sop} realm does not pay much, other than being able to define generic operations by pattern matching instead of 

\section{Generics of All Kinds}
\label{sec:allkinds}

\subsection{Generic Functor}

\section{Constraints}
\label{sec:constraints}

\section{The Missing Piece: Existentials}
\label{sec:exists}

\subsection{Finding the Piece in Agda}


%% Acknowledgments
%\begin{acks}
%\end{acks}

\newpage
%% Bibliography
\bibliography{references}

\end{document}
