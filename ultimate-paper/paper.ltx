%% For double-blind review submission, w/ CCS and ACM Reference
\documentclass[sigplan,10pt]{acmart}\settopmatter{printfolios=true}

\newenvironment{myhs}{\par\vspace{0.15cm}\begin{minipage}{\textwidth}}{\end{minipage}\vspace{0.15cm}}

%include lhs2TeX.fmt
%include custom.fmt

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[Haskell'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%\setcopyright{none}
%\setcopyright{acmcopyright}
\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{cleveref}
\usepackage{cmll}
%\usepackage{flushend}

\hypersetup{draft}

\begin{document}

%% Title information
\title{Generic Programming of All Kinds}
\subtitle{Type Constructors and GADTs in Sum-of-Products Style}

\author{Alejandro Serrano}
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{Junior lecturer}
  \department{Dept. of Information and Computing Sciences}
  \institution{Utrecht University}
  \streetaddress{Princetonplein, 5}
  %\city{Utrecht}
  %\state{Utrecht}
  \postcode{3584 CC}
  \country{The Netherlands} 
}
\email{A.SerranoMena@@uu.nl}

\author{Victor Cacciari Miraldo}
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{PhD candidate}
  \department{Dept. of Information and Computing Sciences}
  \institution{Utrecht University}
  \streetaddress{Princetonplein, 5}
  %\city{Utrecht}
  %\state{Utrecht}
  \postcode{3584 CC}
  \country{The Netherlands} 
}
\email{V.CacciariMiraldo@@uu.nl}


\begin{abstract}
Datatype-generic programming is a widely used technique to define functions
that work regularly over a class of datatypes. Examples include deriving serialization
of data, equality or even functoriality. The \emph{state-of-the-art} of generic
programming still lacks handling GADTs, multiple type variables, and some other features.
This paper exploits modern GHC extensions, including |TypeInType|, to
handle arbitrary number of type variables, constraints, and existentials.
We also provide an Agda model of our construction that does \emph{not}
require Russel's paradox, proving the construction is consistent.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
<concept_desc>Software and its engineering~Functional languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011008.10011024.10011028</concept_id>
<concept_desc>Software and its engineering~Data types and structures</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~Data types and structures}
%% End of generated code

\keywords{Generic programming, Haskell}

\maketitle


\section{Introduction}
(Datatype)-generic programming is a technique to define functions
by induction over the structure of a datatype. Simpler mechanisms,
such as the |deriving| clause, have been present in Haskell for a long
time \cite{haskell2010}, although restricted to a few generic
operation such as equality. Over the years, many different approaches
have been described to allow the definition of generic functions by
the programmer (see~\cite{Rodriguez2008,Magalhaes2012} for a
comparison). Ultimately, GHC added special support via the
|Data|~\cite{Lammel2003,Mitchell2007} and
|Generic|~\cite{Magalhaes2010} type classes.

The built-in |Generic| uses a lightweight encoding.
One of its key design aspects is to \emph{not} represent
recursion explicitly, as opposed to \texttt{regular}~\cite{Noort2008},
\texttt{multirec}~\cite{Yakushev2009}, and
\texttt{generic-mrsop}~\cite{MrSop}.
Our approach is inspired by the same lightweight
philosophy, but we extend it much further, enabling the programmer to
employ generic programming techniques to much more expressive
datatypes.

  For instance, |Generic| only supports representing ground types,
that is, types of kind |Star|. It does provide a second typeclass,
|Generic1|, for type constructors of kind |k -> Star|, but that is
as far as it goes. Our techniques are able to represent types of
arbitrary kinds by using some of the more modern features of the
Haskell language.

Our work builds upon many recent extensions to the Haskell language,
which have been implemented in GHC. The list includes datatype
promotion, kind polymorphism ~\cite{Yorgey2012}, the |Constraint|
kind~\cite{constraintkinds}, and
|TypeInType|~\cite{Weirich2013,Weirich2017}.  Regarding the latter, we
show that our construction does \emph{not} require the |Star : Star| axiom
by attaching a model in Agda~(\Cref{sec:agda}).  Nevertheless, using
these recent additions we drastically expand the amount of Haskell
datatypes we can represent generically compared to other
approaches. Take for example the following datatype for simple
well-typed expressions:
\begin{myhs}
\begin{code}
data Expr :: Star -> Star where
  Lit  :: a -> Expr a
  IsZ  :: Expr Int -> Expr Bool
  If   :: Expr Bool -> Expr a -> Expr a -> Expr a
\end{code}
\end{myhs}
Internally, GHC enforces a specific type in a constructor -- as |Bool|
in the constructor |Eq| above -- by using equality constraints.
Thus the previous declaration is internally translated to the following form:
\begin{myhs}
\begin{code}
data Expr :: Star -> Star where
  Lit  :: a -> Expr a
  IsZ  :: a ~ Bool => Expr Int -> Expr a
  If   :: Expr Bool -> Expr a -> Expr a -> Expr a
\end{code}
\end{myhs}

Using the approach presented in this paper, this type is encoded
using a list of lists of atoms. The outer list represents the choice
of constructors, and the inner list represents
the fields of such constructors.
\begin{myhs}
\begin{code}
type CodeExpr =
  P  [  P  [  Explicit V0 ],
        P  [  Implicit (Kon (~) :@: V0 :@: Kon Bool ),
              Explicit (Kon Expr :@: Kon Int) ],
        P  [  Explicit (Kon Expr :@: Kon Bool),
              Explicit (Kon Expr :@: V0), 
              Explicit (Kon Expr :@: V0) ]]
\end{code}
\end{myhs}
The three constructors translate into three elements in the outer list.
Each of the inner lists contain a list of fields.
The type of each of their fields are represented using the
applicative fragment of $\lambda$-calculus. Constant types and type
constructors are brought in via |Kon|, application is represented
by |(:@:)|, and |V0|, |V1|, \dots represent each of the type variables
of the datatype. For example, the constraint |a ~ Bool| is represented
as the application of the type constructor |(~)| to the first
argument |V0| and the constant |Kon Bool|.
Our encoding ensures that everything is \emph{well-kinded}.

If a field represents a constraint in Haskell code, it is marked
as \emph{implicit} in the code. This is the case for the equality
|a ~ Bool| above. All other fields are marked as explicit.

\subsection{Contributions}

The main contribution of this paper is to provide a \emph{single,
unified} type class for generic programming, which supports algebraic
data types and type constructors of \emph{all kinds}
(\Cref{sec:allkinds}) by using a variant of
the sum-of-products representation.
Before delving into the most general framework, we explore the required background
in \Cref{sec:pre}, and provide a first extension of the sum-of-products style
for type constructor with a single parameter in \Cref{sec:generic1}.

Since the introduction of Generalised Algebraic
Data Types \cite{Xi2003}, \emph{GADTs} for short,
datatype constructors may have more complicated
shapes than a mere list of fields:
\begin{itemize}
  \item Each constructor may require one or more \emph{constraints} to
  be satisfied by the types of their fields. The |Expr| datatype defined
  above is a prime example of this feature.
%   For example, when we write
%  a datatype to witness the equality between two types:
%  \begin{myhs}
%  \begin{code}
%  class Eql a b where
%    Refl :: a ~ b => Eql a b
%  \end{code}
%  \end{myhs}
%  we require the indices of |Eql|, namely |a| and |b|, to be equal. This
%  is represented by the constraint |a ~ b| in the |Refl| constructor.
  In \Cref{sec:constraints}
   we explore how to extend our base framework to
  account for these constraints.

  \item Constructors may introduce new type variables.
  These are called \emph{existentials}, since
  once you pattern match you know that a type has been used, but not
  exactly which one. The support for existentials is discussed in
  \Cref{sec:exists}.
\end{itemize}

In \Cref{sec:recursion} we address how one could encode explicit
recursion within our approach.

\section{Preliminaries}
\label{sec:pre}
Let us take a step back and take a tour of generic
programming techniques. We will build up in complexity gradually, ultimately
leading to our approach. We focus on the |Generic| line of work,
whose main characteristic is the use of type-level information
to represent the \emph{shape} of datatypes.

Each generic programming library provides different \emph{building blocks}
for the representations. For example, |Generic| uses the following
set of functors and combinators:\footnote{In the actual library, |K1|
has an additional type parameter |i|, which was used
to distinguish recursive positions from non-recursive ones. In latest
versions this distinction has been removed and |i| is always set to |R|,
but the type parameter remains for backwards compatibility.}
\begin{myhs}
\begin{code}
data V1           p                           -- empty
data U1           p = U1                      -- unit
data K1   c       p = K1 c                    -- constant
data (f  :+:  g)  p = L1 (f p) | R1 (g p)     -- sum
data (f  :*:  g)  p = (f p) :*: (g p)         -- product
\end{code}
\end{myhs}
By combining these blocks we can describe the structure of any
algebraic datatype. We encode the choice of constructors by sums, and
the combination of fields of a constructor by products, or by the unit
functor if there are none. In turn, each field is represented by a
constant functor. To make things more concrete, here is a definition
for binary trees:
\begin{myhs}
\begin{code}
data Tree a = Leaf | Node (Tree a) a (Tree a)
\end{code}
\end{myhs}
The shape of this datatype is described as follows:
\begin{myhs}
\begin{code}
U1 :+: (K1 (Tree a) :*: K1 a :*: K1 (Tree a))
\end{code}
\end{myhs}
The type above is the \emph{representation} of |Tree
a|. Note that this representation refers to the type |Tree a| itself.
Hence, we say that recursion is encoded \emph{implicitly} here.
Other approaches to generic programming use a specific combinator for marking recursive
positions instead~\cite{Noort2008,Yakushev2009}.

The combinators presented above are enough to
describe the structure of a datatype, but not metadata such as the names
of the type and constructor. |Generic| includes an additional functor
|M1| for that purpose, but we omit further discussion for the sake of
conciseness.

In order to use generic operations, we must tie each datatype with
its representation. This is done via the |Generic| type class. In
addition, we ought to witness the isomorphism at the term level via a
pair of functions |to| and |from|.
\begin{myhs}
\begin{code}
class Generic a where
  type Rep a :: Star -> Star
  from  :: a -> Rep a p
  to    :: Rep a p -> a
\end{code}
\end{myhs}
Fortunately, we do not have to write |Generic| instances by hand. GHC
provides an extension to the |deriving| mechanism to create these
instances. In fact, all generic programming libraries automate this
step, making use of metaprogramming facilities such as Template
Haskell~\cite{Sheard2002}. In many cases, generic descriptions can also be
derived from the compiler-generated one~\cite{Magalhaes2014}.

%Before exploring the novel ideas in the paper, we need to recap some
%notions from the current landscape of generic programming in GHC. As
%in the Introduction, we focus on the |Generic| line of work.

\subsection{Generic operations}
\label{sec:genericops}

In order to define an operation generically, we create two dedicated
\emph{type classes}, one for ground types and one for type
constructors. Take the |size| function, which counts the
number of constructors.
\begin{myhs}
\begin{code}
class Size a where
  size   ::   a    -> Integer

class GSize f where
  gsize  ::   f p  -> Integer
\end{code}
\end{myhs}
All we have to do is to write instances of the second class for each of the building
blocks of datatypes. The type class mechanism is how we reflect the
type level structure into a term level implementation.
\begin{myhs}
\begin{code}
instance (GSize f , GSize g) => GSize (f :*: g) where
  gsize (f :*: g)  = gsize f + gsize g

instance (GSize f , GSize g) => GSize (f :+: g) where
  gsize (L1 f)     = gsize f
  gsize (R1 g)     = gsize g

instance (Size c) => GSize (K1 c) where
  gsize (K1 x)     = size x
\end{code}
\end{myhs}
Note how the instance of constants |K1| points back to the type class
for ground types, |Size|. We need one such instance for each datatype;
but now we can reuse the generic implementation if we first transform
the value into its representation.
\begin{myhs}
\begin{code}
instance Size Int where
  size n = 1

instance Size (Tree a) where
  size t = gsize (from t)
\end{code}
\end{myhs}
By using the |default| keyword~\cite{Magalhaes2010} available in GHC,
the implementation of |size| in terms of |gsize| can be completely automated.
In that case, only an empty |instance| declaration for |Size| is required.
The recent |deriving via| proposal~\cite{DerivingVia} provides another
way to automatize the creation of such instances.

The definition of |size| is very simple, other generic operations such
as |show| or |parse| need to access the metadata and keep additional
information around.

\subsection{Sums of Products}

The landscape of type-level programming in GHC changed radically after
the introduction of \emph{datatype promotion}~\cite{Yorgey2012}, which is
used by the \texttt{generics-sop} library~\cite{deVries2014}
to guarantee the sum-of-products invariants.

Briefly, by
promoting a datatype you can use its constructors as types,
and the type being defined is promoted to a kind. For example,
we can use a promoted Boolean value to encode whether a certain string
has been validated or not.
\begin{myhs}
\begin{code}
newtype VString (v :: Bool) = VString String

validate :: VString False -> VString True
\end{code}
\end{myhs}

In particular, \texttt{generics-sop} makes heavy use of promoted lists.
Each datatype is
described by a list of list of types, where the outer level should be
thought as the choice between constructors, and each inner list
represents the fields in that constructor. This structure corresponds
to that of algebraic datatypes in Haskell, and it is called
\emph{sum of products}. We refer to the list of list of types
which describe a datatype as the \emph{code} of that datatype.
For example, here is the code for
|Tree a| defined above:\footnote{The quote sign serves to
differentiate type level from term level when there is a risk of
confusion. For example, |[]| is the name of the list \emph{type constructor},
whereas |P []| is the \emph{promoted empty list}.}
\begin{myhs}
\begin{code}
P [ P [], P [Tree a, a, Tree a]]
\end{code}
\end{myhs}
In contrast, the representation using |Generic| is not
strong enough to guarantee that shape; the compiler does not stop
us from writing:
\begin{myhs}
\begin{code}
U1 :*: (K1 Int :+: Maybe)
\end{code}
\end{myhs}
that is, a product of sums instead of a sum of products. Furthermore, it
uses a functor |Maybe| which is not part of the basic building blocks.

Unfortunately, a new problem arises: we cannot construct terms of the code
directly, we first need to turn it into a ground type. The kind of the
type level list is |[[Star]]| -- where |Star| is the kind of ground
types in Haskell -- yet, we can only write terms of kind
|Star|. The bridge between the two worlds is given by the following
two GADTs: |NS|, which interprets a list of elements as a choice, and
|NP|, which requires a value for each element in the list, and thus encodes a
product.
\begin{myhs}
\begin{code}
data NS  :: (k -> Star) -> [k] -> Star where
  Here    :: f k      -> NS f (k qcolon ks)
  There   :: NS f ks  -> NS f (k qcolon ks)

data NP  :: (k -> Star) -> [k] -> Star where
  Nil   ::                    NP f (P [])
  (:*)  :: f x -> NP f xs ->  NP f (x qcolon xs)
\end{code}
\end{myhs}
Both |NS| and |NP| receive as first argument a type constructor
of kind |k -> Star|. Both |NS| and |NP| apply that constructor
to the elements of the list: to one of them in |Here|, and to all
of them in |(:*)|.

The most common combination of |NS| and |NP| is used to obtain
the ground type representing a certain code |c|:
\begin{myhs}
\begin{code}
type SOP c = NS (NP I) c
\end{code}
\end{myhs}
The idea is that we choose one of the constructors in the outer list
by using |NS|, and then apply |NP I| to ask for one value of every element
for the chosen constructor. The argument to |NP| is the identity functor |I|
defined as:
\begin{myhs}
\begin{code}
data I p = I p
\end{code}
\end{myhs}
As a result, we require for each field one value of exactly the type
declared in the inner list. As we shall see, the ability to manipulate
the inner lists is paramount to our approach.

Just like the built-in |Generic|, each datatype is tied to its
code by a type class. In the \texttt{generics-sop} this class is also known
as |Generic|, but we use a superscript to distinguish it.
\begin{myhs}
\begin{code}
class GenericSOP a where
  type Code a :: [[Star]]
  from  :: a -> SOP (Code a)
  to    :: SOP (Code a) -> a
\end{code}
\end{myhs}

This approach to generic programming allows the definition of generic
operations without resorting to the type class mechanism. By pattern
matching on the |NS| and |NP| constructors we gain enough information
about the shape of the datatype. For example, here is the definition
of the generic |size| operation:
\begin{myhs}
\begin{code}
gsize :: (GenericSOP a, All2 Size (Code a)) => a -> Integer
gsize = goS . from
  where  goS (Here   x)  = goP  x
         goS (There  x)  = goS  x
         goP Nil         = 0
         goP (x :* xs)   = size x + goP xs
\end{code}
\end{myhs}
The only remarkable part of this implementation is the use of the
|All2| type class to ensure that every type which appears in a field
of the code has a corresponding |size| operation. We omit further details
about |All2|, the interested reader is referred to \citet{deVries2014}.

\section{Generic Type Constructors}
\label{sec:generic1}

If we want to write functions such as |fmap|, from |Functor|, generically,
we need to have knowledge about which fields of a type of kind |Star -> Star|
are, in fact, an occurence of its type parameter. In this section we
look into how this has been done by |GHC.Generics| and how to
translate this to the \texttt{generics-sop} style.

\subsection{Type constructors using |Generic1|}

The |Generic1| type class is the counterpart of |Generic| for types
with one parameter, such as |Maybe| or |[]|. The definition is pretty
similar, except that |from1| and |to1| take as argument an
instantiated version |f a| of the type constructor |f|. The same
instantiation is done in the generic representation.
\begin{myhs}
\begin{code}
class Generic1 f where
  type Rep1 f :: Star -> Star
  from1  :: f a -> Rep f a
  to1    :: Rep f a -> f a
\end{code}
\end{myhs}

We now need to extend our set of building blocks, since in the case of
type constructors we have an additional possibility for the fields,
namely referring to the type variable |a| in |f|.
|Par1| is used to represent the case in which the type variable
appears ``naked'', that is, direcly as |a|:
\begin{myhs}
\begin{code}
data Par1 p = Par1 p
\end{code}
\end{myhs}
|Par1| is not enough to represent a type like |Tree a|, in which |a| also
appears as part of a larger type -- in this case |Tree a| again for the
subtrees. We introduce another building block:
\begin{myhs}
\begin{code}
data Par1    p = Par1 p
data Rec1 f  p = Rec1 (f p)
\end{code}
\end{myhs}
We can now give a representation of the |Tree| type constructor. In
contrast, before we had defined a family of representations for |Tree
a|, regardless of the |a|.
\begin{myhs}
\begin{code}
U1 :+: (Rec1 Tree :*: Par1 :*: Rec1 Tree)
\end{code}
\end{myhs}

Although type application is named |Rec1|, and it is used when we have
recursion in our type, is does not only model recursion.
In fact, every application of a type constructor to the type variable has to
be encoded by the means of |Rec1|, even if this is not a recursive application.

Note that |Rec1| is not expressive enough to represent arbitrary recursion.
If we want to represent non-regular datatypes, such as |Rose a| below:
\begin{myhs}
\begin{code}
data Rose a = Fork a [Rose a]
\end{code}
\end{myhs}
we need some extra machinery in the form of \emph{functor composition}.
We omit discussion of these non-regular datatypes in this section,
but note that the framework in forecoming sections \emph{does}
support this shape of recursion.

Defining generic operations for |Generic1| is done as for |Generic|;
one just need to add additional instances for the new |Par1| and
|Rec1| functors. Here are the important pieces of the generic |fmap|
declaration, taken from the \texttt{generic-deriving} package. The
rest of the instances just apply |gfmap| recursively in every
position.
\begin{myhs}
\begin{code}
class GFunctor f where
  gfmap :: (a -> b) -> f a -> f b

instance GFunctor Par1 where
  gfmap f (Par1 a)  = Par1 (f a)
instance (Functor f) => GFunctor (Rec1 f) where
  gfmap f (Rec1 a)  = Rec1 (fmap f a)
\end{code}
\end{myhs}

Although |Generic1| works well for one type parameter, the general technique
does not scale to more parameters. At the very least, we would need new
|Par1| and |Par2| types which refer to each of the type variables.
\begin{myhs}
\begin{code}
data Par1  a b = Par1  a
data Par2  a b = Par2  b
\end{code}
\end{myhs}
By doing so, the kind of the representation can no longer be |Star ->
Star|, we need at least |Star -> Star -> Star| to accomodate the two
type parameter. Unfortunately, this means that none of |V1|, |U1|,
|(:+:)|, and |(:*:)| can be used, since they all create or operate on
types of kind |Star -> Star|. We could build a completely different
set of primitive building blocks for two-parameter types, but the
problem would repeat again once we consider three parameters. We will
address this issue in \Cref{sec:allkinds}.

\subsection{Type constructors in sum-of-products style}

The key point to extend a generic framework to handle type
constructors is to introduce marks for those places where the type
parameter ought to appear. In the case of |Generic1|, it was only a
matter of adding new |Par1| and |Rec1| types.

The approach taken by \texttt{generics-sop} is to describe a datatype
by a list of list of types. Ultimately, the elements of the nested
lists are ground types, of kind |Star|. This precludes us from using
the same form of codes directly, since we cannot add an indicators for
variables or recursion. Instead, we introduce \emph{atoms}, which
describe the choice we have for each of our fields:
\begin{myhs}
\begin{code}
data Atom = Var | Rec (Star -> Star) | Kon (Star)
\end{code}
\end{myhs}
A code is no longer represented by |[[Star]]|, but rather
|[[Atom]]|. The |NS| and |NP| types which interpret those codes are
still valid; the nested list structure is still there. But we also
need to interpret each of the atoms into a value of kind |Star|. For
that we introduce yet another layer, which we call |NA|:
\begin{myhs}
\begin{code}
data NA :: Star -> Atom -> Star where
  V :: a    -> NA a Var
  R :: f a  -> NA a (Rec f)
  K :: k    -> NA a (Kon k)
\end{code}
\end{myhs}
Each of the constructors in |NA| closely matches the definition of
|Par1|, |Rec1|, and |K1| in the |Generic1| framework. The code for our
running example, |Tree|, reads as follows:
\begin{myhs}
\begin{code}
P [ P [], P [ Rec Tree, Var, Rec Tree ] ]
\end{code}
\end{myhs}

We can now define the |Generic1SOP| type class which ties each
datatype to its code. We also define a |SOP1| type synonym for the
nested application of the interpretation functors |NS|, |NP|, and
|NA|:
\begin{myhs}
\begin{code}
type SOP1 c a = NS (NP (NA a)) c

class Generic1SOP (f :: Star -> Star) where
  type Code1 f :: [[Atom]]
  from1  :: f a -> SOP1 (Code1 f) a
  to1    :: SOP1 (Code1 f) a -> f a
\end{code}
\end{myhs}
Up to this point we have omitted the implementation of the functions
which witness the isomorphism between a regular datatype and its
generic representation. It is instructive to consider how it looks for
the case of |Tree| seen as a type constructor:
\begin{myhs}
\begin{code}
instance Generic1SOP Tree where
  dots
  from Leaf =  Here    Nil
  from (Node l x r)
    = There $  Here $  R l :* V x :* R r :* Nil
\end{code}
\end{myhs}
After a sequence of |There| and |Here| indicating which
constructor we are working with, we find a |(:*)|-separated list of
fields, finished by |Nil|. In each case we need to mark whether that
field arises from an application of a type constructor to the
parameter (with |R|), for an ocurrence of the type parameter (with
|V|), or simply from a constant type (with |K|, not shown in this
example).

\begin{figure}
\begin{myhs}
\begin{code}
gfmap  ::  forall f a b dot
           (Generic1SOP f, AllRec2 Functor (Code1 f))
       =>  (a -> b) -> f a -> f b
gfmap f = to . goS . from
  where
    goS  ::  AllRec2 Functor xs
         =>  NS (NP (NA a)) xs -> NS (NP (NA b)) xs
    goS (Here   x) = Here   (goP x)
    goS (There  x) = There  (goS x)
        
    goP  ::  AllRec Functor xs
         =>  NP (NA a) xs -> NP (NA b) xs
    goP Nil          = Nil
    goP (R x :* xs)  = (R $ fmap f x)  :* goP xs
    goP (V x :* xs)  = V (f x)         :* goP xs
    goP (K x :* xs)  = K x             :* goP xs

type family AllRec2  c xs :: Constraint where
  AllRec2 c (P [])          = ()
  AllRec2 c (x qcolon xs)   = (AllRec c x, AllRec2 c xs)

type family AllRec   c xs :: Constraint where
  AllRec c (P [])               = ()
  AllRec c (Rec x  qcolon xs)   = (c x, AllRec c xs)
  AllRec c (x      qcolon xs)   = AllRec c xs
\end{code} %$
\end{myhs}
\caption{Generic |fmap| using |Generic1SOP|}
\label{fig:gfmap2}
\end{figure}

Armed with our new |Generic1SOP|, we can implement a generic version
of |fmap|, given in \Cref{fig:gfmap2}. The code is a bit more complex
than |gsize|, though. The types involved in 
|goS|, |goP|, and |goA| are too complex to be inferred, hence, we
must help the compiler by annotating the local declarations.

We cannot use the same type family |All2| that we were using, because
we need to treat |Rec| positions differently from the rest. The
solution is to define a more specific |AllRec2| type family, which
only applies the a constraint |c| only over those positions. Unfortunately,
we have not yet found a way to implement |AllRec2| in terms of |All2|.

\section{Generics of All Kinds}
\label{sec:allkinds}

The extension of |GenericSOP| to |Generic1SOP| was done in three
steps. First, we changed the language of codes from lists of lists
of \emph{types}, to lists of lists of \emph{atoms}. By doing so, we were able to
refer to type parameters via |Var| and
encode recursion via |Rec|. Next, we introduced
an interpretation functor |NA| for atoms. Finally, we defined
the |Generic1SOP| type class to tie each datatype to its code. In
this section we follow the same three steps, but this time we go further.
The resulting generic type-class supports types of arbitrary kinds.

The first step is representing each of the types
of the fields, that is, estabilishing our new language of atoms. 
In \Cref{sec:generic1} we discussed the problem
of nested recursion, as in |Rose|. Here this problem is magnified; for example,
in the following datatype of kind |Star -> (Star -> Star) -> Star ->
Star|:
\begin{myhs}
\begin{code}
newtype ReaderT r m a = Reader (r -> m a)
\end{code}
\end{myhs}
the second type variable is applied to the third one. We cannot
foresee all possible combinations of recursion and application, and
thus extending the possibilities of the |Rec| constructor from |Atom|
is a dead end.

Looking at the Haskell Report~\cite[section 4.1.2]{haskell2010}, we see
that a type follows closely the applicative fragment of the $\lambda$-calculus:
it is either a type variable, a type constructor, or an application.
We use well-known techniques to represent the structure of these types
as terms:
\begin{enumerate}
\item We use de Bruijn indices to refer to variables.
\item We prevent ill-kinded types such as |Kon Int :@: Var Z| by keeping
track of the kind of the type being described as an index~\cite{BAARS201051}.
\end{enumerate}
In \Cref{fig:atomdefn} we define two GADTs, |TyVar| and |Atom|, to represent
types. For the sake of clarity, we also define a
synonym |Kind| for |(Star)|,
which we used whenever the instantiation of a type argument represents
a kind as opposed to a regular type. Both |TyVar| and |Atom| receive two
|Kind|-indices: the first one |dtk| represents the kind of the datatype
we are describing, and the second one |k| gives the kind of the type
represented by the |Atom| itself. The latter index is the one preventing
ill-kinded expressions such as |Kon Int :@: Var Z|.

\begin{figure}
\begin{myhs}
\begin{code}
type Kind = (Star)

data TyVar  (dtk :: Kind) (k :: Kind) :: (Star) where
  VZ  ::                TyVar (x -> xs) x
  VS  :: TyVar xs k ->  TyVar (x -> xs) k

data Atom   (dtk :: Kind) (k :: Kind) :: (Star) where
  Var    :: TyVar dtk k  -> Atom dtk k
  Kon    :: k            -> Atom dtk k
  (:@:)  :: Atom dtk (ell -> k) -> Atom dtk ell  -> Atom dtk k
\end{code}
\end{myhs}
\caption{Definition of |Atom|}
\label{fig:atomdefn}
\end{figure}

The |TyVar| represents a de Bruijn index into the datatype |dtk|.
We represent this index as a Peano numeral using |VZ| and |VS|, and ensure
that references are never out of bounds.
For simplicity, we also introduce some synonyms 
in order to make the descriptions of types in the rest of
the paper a bit more concise:
\begin{myhs}
\begin{code}
type V0  = Var VZ
type V1  = Var (VS VZ)
type V2  = Var (VS (VS VZ))
\end{code}
\end{myhs}

A datatype of kind |dtk| is now encoded as a list of list of the atoms
defined above, given that they form a type of kind |Star|.
We define a type synonym |DataType| to refer to such lists:
\begin{myhs}
\begin{code}
type DataType dtk = [[Atom dtk (Star)]]
\end{code}
\end{myhs}

At this point we need the |Atom| datatype to be promoted, in order
to use it in the list defining the code. Since |Atom| is a GADT,
we are required to enable the |TypeInType| extension to promote it.
However, we are not using
the |Star : Star| judgement in our construction, we discuss this matter in
\Cref{sec:inconsistent1}. 

As an example, here are the codes corresponding to |[]|, |Either|, and
|Rose|. The fact that |Either| has two type parameter can be observed
by the usage of both |V0| and |V1|. The
non-regular recursion pattern in |Rose| is translated to iterated uses
of the application |(:@:)|.
\begin{myhs}
\begin{code}
type ListCode    = P [ P [ ], P [ V0, Kon [] :@: V0 ] ]
type EitherCode  = P [ P [ V0 ], P [ V1 ] ]
type RoseCode    = P [ P [ V0, Kon [] :@: (Kon Rose :@: V0) ] ]
\end{code}
\end{myhs}

\paragraph{Interpreting Atoms.} In order to interpret this new language,
none of the previously defined |NS| and |NP| require any modifications. 
On the other hand, the interpretation of
atoms requires some type engineering. Recall the definition of |NA|
given in \Cref{sec:generic1}:
\begin{myhs}
\begin{code}
data NA :: Star -> Atom -> Star where
  V :: a -> NA a Var
  dots
\end{code}
\end{myhs}
The first argument of kind |Star| represents the type of the argument
of the functor we are interpreting. In the current setting, we might have an
arbitray number of arguments, and these might be of arbitrary kinds
other than |Star|.
This notion is
not new: to interpret a term possibly containing variables we need a
\emph{context} --- commonly represented by the Greek letter $\Gamma$
-- which assigns a type to each of the variables. Other than the
special shape of the index, the datatype for contexts looks very much
like an heterogeneous list.
\begin{myhs}
\begin{code}
data LoT (dtk :: Kind) where
  LoT0    ::                 LoT (Star)
  (:&&:)  :: k -> LoT ks ->  LoT (k -> ks)
\end{code}
\end{myhs}
For example, |Int :&&: Maybe :&&: Char :&&: LoT0| is a well-formed
context of kind |LoT (Star -> (Star -> Star) -> Star -> Star)|.

With the introduction of contexts, we can write a definitive version of |NA|.
In contrast to the previous iteration, we do not have a different constructor
for each possible value of |Atom|. It is not possible to build interpretations
for |Atom| in a compositional way: for example, it is not possible to define the
interpretation |Kon [] :@: Kon Int| by composing interpretations of
|Kon []| and |Kon Int| because the notion of a value of
something of a kind different from |Star|, like |[]|, does not make sense
in Haskell. Instead, we define a type family |Ty| which computes the type
of a field given a context.
\begin{myhs}
\begin{code}
type family Ty dtk (tys :: LoT dtk) (t :: Atom dtk k) :: k where
  Ty (k -> ks) (t :&&: tys) (Var VZ)      = t
  Ty (k -> ks) (t :&&: tys) (Var (VS v))  = Ty ks tys (Var v)
  Ty dtk tys (Kon t)    = t
  Ty dtk tys (f :@: x)  = (Ty dtk tys f) (Ty dtk tys x)
\end{code}
\end{myhs}

In preparation for the upcoming constructions, we introduce the type
variables for the |T| constructor explicitly. In particular, this is
required to use visible type application~\cite{EisenbergWA16}. The code
uses record syntax to generate an eliminator |unT| for the only field
in |T|.\footnote{Not to be confused with Agda and Idris' syntax for
implicit parameters.}
\begin{myhs}
\begin{code}
data NA (dtk :: Kind) :: LoT dtk -> Atom dtk (Star) -> Star where
  T :: forall dtk t tys dot { unT :: Ty dtk tys t } -> NA dtk tys t
\end{code}
\end{myhs}
These new parameters
to |NA| appear also in the new |SOPn| type, which interpets codes of
the new shape:
\begin{myhs}
\begin{code}
type SOPn (dtk :: Kind) (c :: DataType dtk) (tys :: LoT dtk)
  = NS (NP (NA dtk tys)) c
\end{code}
\end{myhs}

\paragraph{A unified |GenericNSOP|.} The definition of the generic
representation of a certain datatype is not comprised only of its
code, the two isomorphisms |from| and |to| are also required. 
In our case, however, it seems like there is a family of such conversion
functions:
\begin{myhs}
\begin{code}
from   :: f      -> SOPn (Star)              (Code f) LoT0
from1  :: f a    -> SOPn (k1 -> Star)        (Code f) (a :&&: LoT0)
from2  :: f a b  -> SOPn (k1 -> k2 -> Star)  (Code f) (a :&&: b :&&: LoT0)
-- and so on
\end{code}
\end{myhs}
The difficulty arises on the first argument, since |f| is
applied to a different number of variables in each case. 
Hence, we have to describe this situation as |f|
being applied to a \emph{context} whose length varies.
\begin{myhs}
\begin{code}
from   :: Apply f LoT0                  -> SOPn dots
from1  :: Apply f (a :&&: LoT0)         -> SOPn dots
from2  :: Apply f (a :&&: b :&&: LoT0)  -> SOPn dots
-- and so on
\end{code}
\end{myhs}
Where |Apply| is defined as a type family. In order
to help the compiler in forecoming developments, we also include the
kind of the context as an explicit argument to this family.
\begin{myhs}
\begin{code}
type family Apply dtk (f :: dtk) (tys :: LoT dtk) :: (Star) where
  Apply (Star)     f LoT0         = f
  Apply (k -> ks)  f (t :&&: ts)  = Apply ks (f t) ts
\end{code}
\end{myhs}

\begin{figure}
\begin{myhs}
\begin{code}
class GenericNSOP dtk (f :: dtk) where
  type Code f :: DataType dtk
  from  ::  ApplyT dtk f tys -> SOPn dtk (Code f) tys
  to    ::  SSLoT dtk tys
        =>  SOPn dtk (Code f) tys -> ApplyT dtk f tys

data ApplyT dtk (f :: k) (tys :: LoT dtk) :: Star where
  A0   :: { unA0   ::  f  }  -> ApplyT (Star)     f  LoT0
  Arg  :: { unArg  ::  ApplyT ks (f t) ts  }
                             -> ApplyT (k -> ks)  f (t :&&: ts)

data SLoT (dtk :: Kind) (tys :: LoT dtk) where
  SLoT0  ::                 SLoT (Star)     LoT0
  SLoTA  ::  SLoT ks as ->  SLoT (k -> ks)  (t :&&: ts)

class SSLoT k (tys :: LoT k) where
  sslot :: SLoT k ts
instance SSLoT (Star) LoT0 where
  sslot = SLoT0
instance SSLoT ks ts => SSLoT (k -> ks) (t :&&: ts) where
  sslot = SLoTA sslot
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
instance GenericNSOP (Star -> Star) [] where
  type Code [] = P [ P [ ], P [ V0, Kon [] :@: V0 ] ]

  from (Arg (A0 []))        =          Here $ Nil
  from (Arg (A0 (x : xs)))  = There $  Here $ T x :* T xs :* Nil
  
  to   ::  forall tys dot SSLoT (Star -> Star) tys
       =>  SOPn (Star -> Star) (Code []) tys -> ApplyT (Star -> Star) [] tys
  to sop = case sslot @(Star -> Star) @tys of
    SLoTA SLoT0 -> case sop of
               Here Nil                    -> Arg $ A0 []
      There (  Here (T x :* T xs :* Nil))  -> Arg $ A0 $ x : xs
\end{code}
\end{myhs}
\caption{The |GenericNSOP| class and its instance for lists}
\label{fig:genericnsoplist}
\end{figure}

This is not yet sufficient to type either the |from| or |to| functions. 
The complete declarations can be found in \Cref{fig:genericnsoplist},
together with an example instance.
For pedagogical purposes, let us start from a naive type signature for |to| 
and build it up to the real signature, one piece at a time. We start with:

\begin{myhs}
\begin{code}
to :: SOPn dtk (Code f) tys -> Apply dtk f tys
\end{code}
\end{myhs}

Here the type variable |f| appears only as an argument of type families:
|Apply| and |Code|.
None of the type families are injective, which means that the
instantiation of |f| cannot be inferred in its usage sites. In fact,
if we have |Either a b| as a result, there are three different calls
to |Apply| which would give the same result:
%\footnote{Although one could
%argue that the combination of the result of |Apply| and the sequence
%of types |tys| is enough to fix the parameter |f|.}
\begin{myhs}
\begin{code}
Apply (Star -> Star -> Star)  Either        (a :&&:   b   :&&:  LoT0)
Apply (Star -> Star)          (Either a)              (b  :&&:  LoT0)
Apply (Star)                  (Either a b)                      LoT0
\end{code}
\end{myhs}
Datatypes, on the other hand, are injective. Hence we lift |Apply|
to a GADT, |ApplyT|. This provides \emph{evidence}  of which part of the type
is the constructor |f| and which are the type parameters.

Next, we need to inform the typechecker about the shape of the context
|LoT dtk|. Unfortunately Haskell cannot infer that only from the kind
|dtk|, even though this should be enough in theory. We introduce
singletons for contexts, |SLoT|, and an accompanying type class
|SSLoT|, which witnesses the one-to-one correspondence between the
singleton term and its indexed context.  In short, a singleton for
|tau| is a datatype indexed by that |tau| which accurately reflects
the structure of |tau|~\cite{Eisenberg2012}.  Thus, by pattern
matching on the singleton, we gain information about |tau| itself. In
this case, the information about the shape of the context is reified.

\subsection{Generic Functor}

\begin{figure}
\begin{myhs}
\begin{code}
gfmap  ::  forall f a b dot  (GenericNSOP (Star -> Star) f,
           All2 FunctorAtom (Code f))
       =>  (a -> b) -> f a -> f b
gfmap f  =            unA0 . unArg . to
         .  goS  .    from . Arg . A0
  where
    goS  ::  All2 FunctorAtom xs
         =>  NS (NP (NA (Star -> Star) (a :&&: LoT0))) xs
         ->  NS (NP (NA (Star -> Star) (b :&&: LoT0))) xs
    goS (Here   x) = Here   (goP x)
    goS (There  x) = There  (goS x)

    goP  ::  All FunctorAtom xs
         =>  NP (NA (Star -> Star) (a :&&: LoT0)) xs
         ->  NP (NA (Star -> Star) (b :&&: LoT0)) xs
    goP Nil          = Nil
    goP (T x :* xs)  = gfmapF f (T x) :* goP xs

class FunctorAtom (t :: Atom (Star -> Star) (Star)) where
  gfmapF  ::  (a -> b)  -> NA (Star -> Star) (a :&&: LoT0) t
                        -> NA (Star -> Star) (b :&&: LoT0) t

instance  FunctorAtom V0 where
  gfmapF f (T x)  =  T (f x)
instance  (Functor f, FunctorAtom x)
          => FunctorAtom (Kon f :@: x) where
  gfmapF f (T x)
    =  T (fmap (unT . gfmapF f . T atunder @x) x)
instance  FunctorAtom (Kon t) where
  gfmapF f (T x)  =  T x
\end{code}
\end{myhs}
\caption{Generic |fmap| using |GenericNSOP|}
\label{fig:gfmap3}
\end{figure}

Just like \Cref{fig:gfmap2}, we can also write a generic |fmap|
for functors in the |GenericsNSOP| universe, given in \Cref{fig:gfmap3}.
In fact, the code in \Cref{fig:gfmap3}, does
not significantly differ from that of \Cref{fig:gfmap2}, where we only
had |Generic1SOP| at our hand. The main change is our treatment of
atoms. In the case of |Generic1SOP|, we knew how to implement |fmap|
for every possible shape of field. However, the language of atoms in
|GenericNSOP| is much broader, and we cannot always write the desired
implementation. In order to delineate which |Atom|s we can handle, we
introduce a |FunctorAtom| type class. The instances correspond to
three different scenarios:
\begin{itemize}
  \item If the field mentions the type variable, then we apply the
  function of type |a -> b| to it.

  \item If the field has the form |f a|, where |f| is a functor and |a|
  the type variable, we can apply the operation under the functor
  |f|. This idea generalizes to fields of the form |f1 (dots (fn a))|,
  giving rise to a recursive instance.

  \item Finally, if the field does not mention the variable, |Kon t|, we
  just keep it unchanged.
\end{itemize}
In the second instance we make use of a partial type signature
|atunder|~\cite{Winant2014}. That way we can ask the compiler to infer
the kind which ought to be passed to |T| from the surrounding
context. In this case it can be readily obtained from the following
|@x| type application.

Note that this use of type classes in the definition of generic |fmap|
is quite different from the usage in \Cref{sec:genericops}. There the
instances describe how to handle sums and products, which we do simply
by recursion on the structure of |NS| and |NP|. In our case
|FunctorAtom| describes which shapes of \emph{atoms} can appear as fields
of a datatype which supports the |Functor| operations. We need such a
restriction because the universe of types we can describe is very wide,
and in many scenarios only a subset of those can be handled.

Another important difference from the |Generic1SOP| version is that we
need to manually wrap and unwrap |ApplyT| constructors |A0| and |Arg|.
Note that the \emph{user} of the generic
operation is oblivious to these fact, they can use the operation
directly, as the following example from the interpreter shows:
\begin{verbatim}
> gfmap (+1) [1,2,3]
[2,3,4]
\end{verbatim}

\paragraph{Arity-generic |fmap|.} The construction in this section can be
generalized to work on type constructors of every kind of the form
|Star -> dots -> Star -> Star|, that is, taking only ground types as
type arguments. Using our framework, we automatize the instantiation of the
following type class |KFunctor|, which generalizes |Functor| and |Bifunctor|
to any kind of the aforementioned shape
\begin{myhs}
\begin{code}
class KFunctor dtk (f :: dtk) where
  kmap  ::  SSLoT dtk bs => Mappings as bs
        ->  ApplyT dtk f as -> ApplyT dtk f bs
\end{code}
\end{myhs}
The |fmap| method in |Functor| takes one single function |a -> b| as argument,
since there is only one type variable to update. The |bimap| in |Bifunctor|
takes two functions, one per argument. The following |Mappings| data type
generalized this idea for |KFunctor|, requiring one function per type variable.
\begin{myhs}
\begin{code}
data Mappings (as :: LoT dtk) (bs :: LoT dtk) where
  MNil   ::  Mappings LoT0 LoT0
  MCons  ::  (a -> b) -> Mappings as bs
         ->  Mappings (a :&&: as)  (b :&&: bs)
\end{code}
\end{myhs}

Assuming the |GenericNSOP| instance for lists, one can implement the usual
|map| function as follows:
\begin{myhs}
\begin{code}
map :: (a -> b) -> [a] -> [b]
map f = unA0 . unArg . kmap (MCons f MNil) . Arg . A0
\end{code}
\end{myhs}
Since we need to pass an |ApplyT| value to |kmap|, we need to manually wrap
and unwrap using |A0| and |Arg|. This process can be automated, though,
and we explain how to do so in the next section. The other detail to consider
is that we need to create a |Mappings| with the single function |f|,
as |[]| only takes one type argument.

The full implementation of |kmap| is given in \Cref{sec:kmap}.
The version described also supports constraints
in datatype constructors as described in \Cref{sec:constraints}.

\subsection{Unraveling Singletons}

Although the type family |Apply| exposes a nicer interface to the programmer,
the introduction of the |ApplyT| datatype was essential for the definition
of |GenericNSOP|. Turns out we can maintain that nice interface 
by wrapping or unwrapping values using |A0| and |Arg| automatically.

Going from |ApplyT| to |Apply| is trivial. This is expected, as |ApplyT|
is a refinement of the type family in which the evidence is explicit.
\begin{myhs}
\begin{code}
unravel :: ApplyT k f tys -> Apply k f tys
unravel (A0   x) = x
unravel (Arg  x) = unravel x
\end{code}
\end{myhs}

For the converse direction, we find ourselves in the same scenario as
for the definition of |to|. In order to define the function, we need
to match on the shape of the context: it the context is empty we wrap
the value using |A0|, and otherwise we add one layer of |Arg|.
The solution is asking for a singleton and inspecting that value instead.
\begin{myhs}
\begin{code}
ravel  ::  forall k f tys dot SSLoT k tys 
       =>  Apply k f tys -> ApplyT k f tys
ravel = go (sslot atunder @tys)
  where
    go  ::  forall k f tys dot SLoT k tys
        ->  Apply k f tys -> ApplyT k f tys
    go SLoT0       x = A0   x
    go (SLoTA ts)  x = Arg  (go ts x)
\end{code}
\end{myhs}
The definition of |gfmap| no longer needs to care about the amount
of wrapping needed by the generic operation, this is inferred from
the types involved.
\begin{myhs}
\begin{code}
gfmap f  =  unravel . to .  goS . from . ravel
\end{code}
\end{myhs}
In fact, we can expose only the combination of (un)raveling with
|to| and |from|, making the writer of generic operations completely
unaware of the intermediate |ApplyT| datatype.

\subsection{Are We Inconsistent?}
\label{sec:inconsistent1}

%format agdatyof = "\mathrel{\HS{:}}"
In order to perform the entire construction, we were forced to enable
the |TypeInType| extension in GHC. This extension is quite powerful:
it allows working with kinds as they were types, and to promote GADTs,
among others. But it also adds an axiom |Star agdatyof Star|, which is known
to introduce inconsistency when we view the language as a
logic~\cite{Girard}. We would like to know whether this latter axiom
is necessary for our construction, or it could be achieved using a
hierarchy of universe levels.

To answer the question we have build a model of |GenericNSOP| in Agda,
which we describe in \Cref{sec:agda}. If we assume that our universe
of basic types lives in |Set0|, our codes live in |Set1|, and our
interpretation of those in |Set2|. The code compiles fine, showing
that the |Star : Star| axiom is not essential to our construction.

\section{Constraints}
\label{sec:constraints}

The move from ADTs to GADTs makes it possible to require a constraint
to be satisfied when using a certain constructor of a datatype. The
|Expr| type described in the Introduction is one example: it mandates
the index to be exactly |Bool| in the |IsZ| case. Here is another example, in which
the constructor |Refl| mandates the two type arguments to coincide by
imposing an equality constraint |a ~ b|.
\begin{myhs}
\begin{code}
data Eql a b where
  Refl :: a ~ b => Eql a b
\end{code}
\end{myhs}

Since version 7.4.1, GHC treats constraints --- in short, anything
which appears before the |=>| arrow --- as regular ground types, with
the caveat that its kind is |Constraint| instead of |Star|.
We sometimes refer to constraints as \emph{implicit} parameters,
since they are filled in by the compiler, as opposed to explicit parameters
which need to be given in the code. In fact, other languages such as
Agda and Scala have a native notion of implicit parameters, which are often
used to simulate Haskell's type class mechanism.

Up to now a datatype was defined as |[[Atom dtk (Star)]]|, where each
element of the inner list represents a field in a constructor. Now we
introduce an additional layer, which specified for each field whether
it is implicit --- and thus should have kind |Constraint| --- or
explicit.
\begin{myhs}
\begin{code}
data Field (dtk :: Kind) where
  Explicit  :: Atom dtk (Star)      -> Field dtk
  Implicit  :: Atom dtk Constraint  -> Field dtk

type DataType dtk = [[Field dtk]]
\end{code}
\end{myhs}
The interpretation functor |NA| has to be adapted:
\begin{myhs}
\begin{code}
data NA (dtk :: Kind) :: LoT dtk -> Field dtk -> Star where
  E ::  forall dtk t tys dot Ty dtk tys t  ->  NA dtk tys (Explicit t)
  I ::  forall dtk t tys dot Ty dtk tys t  =>  NA dtk tys (Implicit t)
\end{code}
\end{myhs}
The two constructors look almost the same. But the fact that |Ty dtk
tys t| appears before a regular |->| arrow in |E|, and before a |=>|
arrow in |I| is enough to require the right kind to come out of the
application of |Ty|. This updated framework is enough to describe the
shape of the |Eql| datatype; we give its |GenericNSOP| instance in
\Cref{fig:eqlgeneric}.
\begin{figure}
\begin{myhs}
\begin{code}
instance GenericNSOP (k -> k -> Star) Eql where
  type Code Eql
    = P [ P [ Implicit (Kon (~) :@: V0 :@: V1) ] ]

  from (Arg (Arg (A0 Refl))) = Here $ I :* Nil

  to   ::  forall tys dot SSLoT (k -> k -> Star) tys
       =>  SOPn (k -> k -> Star) (Code Refl) tys
       ->  ApplyT (k -> k -> Star) Refl tys
  to sop = case sslot atunder @tys of
    SLoTA (SLoTA SLoT0) -> case sop of
      Here (I :* Nil) -> Arg $ Arg $ A0 Refl
\end{code} %$
\end{myhs}
\caption{The |GenericNSOP| instance for |Eql|}
\label{fig:eqlgeneric}
\end{figure}

This is a rather slim layer that has to be added on top of
the previous constructions. Our Agda model in
\Cref{sec:agda} has constraints in it. Hence, this layer
introduces no inconsistency.

\section{Existentials}
\label{sec:exists}

Apart from constraints, every constructor in a GADT may introduce one
or more \emph{existentially quantified type variables}, which are
available once your pattern match. Although seemingly rare,
existentials become ubiquituous once you consider how GHC represents
GADTs. Consider another simple type of well-typed expressions,
which features only integer literals and pairs:
\begin{myhs}
\begin{code}
data Expr' t where
  AnInt  ::  Int -> Expr' Int
  APair  ::  Expr' a -> Expr' b -> Expr' (a, b)
\end{code}
\end{myhs}
Under the hood, the refinement in the index of |Expr'| is turned into an
equality constraint, and every new new variable is quantified. Thus,
we obtain the following form:
\begin{myhs}
\begin{code}
data Expr' t where
  AnInt  ::                  t ~ Int     =>  Int -> Expr' t
  APair  ::  forall a b dot  t ~ (a, b)  =>  Expr' a -> Expr' b
                                         ->  Expr' t
\end{code}
\end{myhs}
Our language of codes is enough to describe |AnInt|, but
cannot handle the introduction of new variables in |APair|. 
Let us look at what would it take to extend our technique to
handle existential types.

Existentials are introduced at the level of constructors. Before, each
constructor was merely a |[Field dtk]|, but now we are going to refine
it with the possibility of introducing new type variables; for each
new variable we need to record its kind. In a dependently-typed
language we can encode this construction using a recursive |Branch|
datatype: we introduce new variables by repeated applications of
|Exists|, and then move to describe the fields with |Constr|.
\begin{myhs}
\begin{code}
data Branch (dtk :: Kind) where
  Exists  ::  (ell :: Kind) -> Branch (ell -> dtk)  -> Branch dtk
  Constr  ::  [Field dtk]                           -> Branch dtk
\end{code}
\end{myhs}
Haskell does not support full dependent types, so |Branch| cannot be
declared as above. As we did in \Cref{sec:allkinds} for the indices of
variables, we use a singleton instead. In contrast with |SNat|,
|SKind| does not reflect any information about the kind itself, but we
do not need to inspect that information either for the upcoming
constructions.\footnote{\citet{ReflectionOnTypes} describes |TypeRep|,
which provides type-indexed type representations. However, it is not
(yet) possible to promote |TypeRep| operations to the type level.}
\begin{myhs}
\begin{code}
data SKind (ell :: Kind) = KK

data Branch (dtk :: Kind) where
  Exists  :: SKind ell -> Branch (ell -> dtk)  -> Branch dtk
  Constr  :: [Field dtk]                       -> Branch dtk
\end{code}
\end{myhs}
As a consequence of this intermediate layer, datatypes are no longer
represented as mere lists of lists of fields, but as |[Branch dtk]|,
where each element contains information both about existentials and
about the fields.

\begin{figure*}
\begin{myhs}
\begin{code}
type TmCode 
     =  ( P [                           Constr (P [  Implicit (Kon (~) :@: Kon Int :@: V0),  Explicit (Kon Int) ]) ,
                Exists KK (Exists KK (  Constr (P [  Implicit (Kon (~) :@: V2 :@: (Kon (,) :@: V1 :@: V0)),
                                                     Explicit (Kon Expr' :@: V1), Explicit (Kon Expr' :@: V0) ] ) ) )  ] )
\end{code}
\end{myhs}
\caption{Code for |Expr'|}
\label{fig:codetm}
\end{figure*}

The |Expr'| datatype above can be described using our extended language
of codes as given in \Cref{fig:codetm}. For that, we do not use the
user-facing version, but the second representation with explicit
quantification and equalities. Note that each |Exists| ``shift'' the
position of type variables: the first variable in the context is now
the second, and so on. As a result, |V0| refers to the last-introduced
variable, |b| in this case, |V1| corresponds to |a|, and |V2| is the
original type argument to |Expr'|, which we called |t| in the datatype
declaration.

\

The next step is to update the interpretation of the
codes. Unfortunately, our datatypes are not described by a list
of lists anymore. This means we cannot define its interpretation as a simple composition
of |NS|, |NP|, and |NA|. We then introduce |NB|, which interprets |Branch|es and has
the form:
\begin{myhs}
\begin{code}
data NB (dtk :: Kind) :: LoT dtk -> Branch dtk -> Star where
  Ex  ::  forall ell (t :: ell) (p :: SKind ell) dtk tys c dot
          NB (ell -> dtk) (t :&&: tys) c  -> NB dtk tys (Exists p c)
  Cr  ::  NP (NA dtk tys) fs              -> NB dtk tys (Constr fs)
\end{code}
\end{myhs}
The recursion in the syntax of existential quantification is reflected
in the recursive use of |NB| in the constructor |Ex|. More
importantly, thanks to the singleton |SKind ell| we can obtain the
kind |ell| which was introduced in the code. Then, we use existential
quantification at the meta-level to generate a fresh type |t| of that
kind, which we add to the context in the first position, matching the
change in the structure that |Exists| performs in the kind. Once we do
not need more existential variables, |Cr| just continues as usual, by
requiring |NP (NA dtk tys)| for the fields |fs|.

Since now the call to |NP| is inside |NB|, we need to update the
top-level |SOPn| type too.
\begin{myhs}
\begin{code}
type SOPn dtk (c :: DataType dtk) (tys :: LoT dtk) = NS (NB dtk tys) c
\end{code}
\end{myhs}
The |GenericNSOP| type class, on the other hand, is not affected by
these changes. The instances, however, need to change their
codes and isomorphisms to reflect the new intermediate layer between
outer and inner lists.

\section{Related Work}

\paragraph{Sums of products.}
Our approach to generic programming is heavily inspired by the
original list-of-list-of-types construction by
\citet{deVries2014}. Each of the extensions we present: support for
multiple kinds, constraints, explicit recursion, and existentials,
could be applied independently of the original framework. Conversely,
\texttt{generics-sop} supports metadata about types and constructors,
and the same techniques are readily applicable to our case.

There seems to be a trade-off in the amount of \emph{traversal
combinators} that can be implemented. \texttt{generics-sop} comes with
a huge library of maps, sequences, and folds. Our definition of
|gfmap|, on the other hand, traverses the |SOPn| structure manually;
and we cannot easily abstract that pattern because of the very strong
types which are involved.

\paragraph{Generic universes.}
%format PredU (j) = "Set_{" j "}"
With respect to our Agda model, \Cref{sec:agda}, we have adapted the technique
of generic programming with universes \cite{Altenkirch2006}, where
one separates the description of types from their interpretation into different
hierarchies. That is, if the description of types live in |PredU i|, then
their interpretation lives in |PredU (i+1)|. Differently from \citet{Altenkirch2006},
we enforce that the descriptions must be in the \emph{sums-of-products} shape,
we do not handle mutual recursion and we handle predicates over variables. 
This requires us to put the elements of the interpretation in |PredU (i+2)|. 
These differences stems from the fact that we aim at representing
Haskell datatypes, including GADTs with potential constraints.

\paragraph{GADTs.}
The problem of generic programming for GADTs have not received much
attention in the literature. The approach of \citet{Magalhaes2011} is based on pattern
functors: the basic set of blocks is extended with |CEq|, which
represents equalities at the level of constructors, and a ``mobility
family'' |X| to fake existentials. Our approach reuses most of the
machinery for regular types, by taking advantage of the availability
of |Constraint| as a kind in GHC. Using quantified class
constraints~\cite{Bottu2017}, \citet{ScottBlog} describes how to derive
|Generic| for some GADTs. The approach does not scale, though, to
handle existentials or kinds different from |Star|.

\paragraph{Kind-genericity.}
\citet{Hinze2000,Hinze:2000:NAG:325694.325709}

\citet{Weirich2010} describe arity-generic operations, such as the family
of functions |zipWith|, |zipWith3|, and so on. In their case the
operations are indexed by a natural number which specifies the amount
of arguments; in contrast our development is indexed by contexts
|LoT| which specify the kind of each type variable.

\section{Conclusion and Future Work}

Although we greatly exapended the set of types that the (generic)
programmer has access to, this is still not exhaustive.
With the introduction of the |TypeInType| extension, quantification in types
works as a telescope. That is, the kind of a variable might depend on
the variables introduced before it. For example, here |t| depends on
the kind |dtk|:
\begin{myhs}
\begin{code}
data KTProxy dtk t where
  KTProxy :: forall dtk (t :: dtk) dot KTProxy dtk t
\end{code}
\end{myhs}
The |Exists| combinator in our library only allows
\emph{constant} kinds to quantify over.

Another shortcoming of our library is that only \emph{single}
recursion can be represented. The
\texttt{multirec}~\cite{Yakushev2009} library adds support families of
mutually recursive datatypes, and \texttt{generic-mrsop}~\cite{MrSop}
translated its approach to the sum-of-products style.
However, in both cases all members of a datatype
are restricted to be of kind |*|. It might be possible to use a similar technique
--- adding an index to the |Rec| atom -- to try tackling this. 
The difficulty is in the possibility of different members of the family
having different kinds.

Through several refinements, starting with the original
sum-of-products construction, we have built a generic
programming library supporting a wider range of datatypes. Our
main novelties are the uniform treatment of different kinds,
and the support for the most important features in GADTs. To do so, we
have leveraged many of the Haskell extensions proposed in the
literature and available in GHC. 

%% Acknowledgments
%\begin{acks}
%We thank the anonymous reviewers which provided very helpful comments
%and pushed us to simplify and extend our library. The participants of the
%Reading Club at Utrecht provided many suggestions in early
%versions of this paper.
%\end{acks}

%% Bibliography
\bibliography{references}

\newpage
\appendix

\section{Reference Implementation in Agda}
\label{sec:agda}

%option agda

  In this section we shall describe the Agda model of
|GenericsNSOP|. Agda~\cite{Norell09} is a depentently typed language
with a predicative hierarchy of universes. This allows us to
model our construction with a finer level of detail. Ultimately
showing one does not need the |Set : Set| axiom to make the construction
work. 

%format holder = "\_"
%format KK = "\mathbb{K}"
%format KZ = "\star"
%format KS a b = "{" a "}\Rightarrow {" b "}"
%format forall = "\forall"
%format (interpK (a)) = "\llbracket {" a "}\rrbracket_{\mathbb{K}}"
%format (interpA (a)) = "\llbracket {" a "}\rrbracket_{A}"
%format (interpP (a)) = "\llbracket {" a "}\rrbracket_{P}"
%format (interpS (a)) = "\llbracket {" a "}\rrbracket_{S}"
%format Gamma = "\Gamma"
%format gamma = "\gamma"
%format alpha = "\alpha"
%format pi    = "\pi"

  The starting point for our construction is modelling the
notion of kind, as we aim to encode arbitrarily kinded types.
Here we mimick Haskell's kind syntax.

\begin{myhs}
\begin{code}
data KK : Set where
  KZ                : KK
  KS holder holder  : KK -> KK -> KK
\end{code}
\end{myhs}
 
  Although their semantics are simple, we already need to start
mapping |KK| to |Set1|, since we want to have ground types
in |Set|:

\begin{myhs}
\begin{code}
interpK holder : KK -> Set1
interpK KZ          = Set
interpK (KS k1 k2)  = interpK k1 -> interpK k2
\end{code}
\end{myhs}

  In order to refer to the kind of a type variable within a
larger kind declaration we declare the |TyVar| relation below.
Essentially, an inhabitant of type |TyVar ks k| provides a way
to extract some kind |k| from within |ks|.

\begin{myhs}
\begin{code}
data TyVar : KK -> KK -> Set where
   VZ  : forall {k ks}                   ->  TyVar (KS k ks) k
   VS  : forall {k k' ks} -> TyVar ks k  ->  TyVar (KS k' ks) k
\end{code}
\end{myhs}

  Next, we can define the language of terms and contexts, just like we did
in \Cref{sec:allkinds}:

\begin{myhs}
\begin{code}
data Atom (dk : KK) : KK -> Set1 where
  Var  : forall {k1} -> TyVar dk k1 -> Atom dk k1
  Kon  : forall {k1} -> interpK k1 -> Atom dk k1
  App  : forall {k1 k2} -> Atom dk (KS k1 k2) -> Atom dk k1 
       -> Atom dk k2

data Gamma : KK -> Set1 where
  GZ : Gamma KZ
  GS : forall {k1 k2} -> interpK k1 -> Gamma k2 -> Gamma (KS k1 k2)
\end{code}
\end{myhs}

  Now, given a environment |gamma|, we can interpret a term
|t : Atom dk k| into an inhabitant of |interpK k|.

\begin{myhs}
\begin{code}
Ty : forall {res k} -> Gamma k -> Atom k res -> interpK res
Ty GZ            (Var ())
Ty (GS g gamma)  (Var VZ)      = gamma
Ty (GS g gamma)  (Var (VS v))  = Ty gamma (Var v)
Ty gamma         (Kon x)       = x
Ty gamma         (App f x)     = Ty gamma f (Ty gamma x)
\end{code}
\end{myhs}

Note how we can discharge the case of interpreting a variable in an
empty environment. Finally, we are now able to define the fields of the constructors. These
come in two flavours. Explicit fields are values of some ground type whereas
implicit fields are constraints over the type parameters in scope.

\begin{myhs}
\begin{code}
data Field (k : KK) : Set2 where
  Explicit : Atom k KZ          -> Field k
  Implicit : (Gamma k -> Set1)  -> Field k
\end{code}
\end{myhs}

  The most interesting part of the model is, in fact, the handling of constraints.
A constraint is a predicate over the types that will be in scope when type
checking that constructor. These types are the interpretation of some kind |k|, 
|interpK k|, and hence, inhabitants of |Set1|. This forces us to map |Gamma k| 
into |Set1|, which brings the universe of |Field| into |Set2|. Interpreting a |Field|
can be done back in |Set1| again:

\begin{myhs}
\begin{code}
interpA holder : forall {k} -> Field k -> Gamma k -> Set1
interpA (Explicit t)    gamma  = Lift (Ty gamma t)
interpA (Implicit ctr)  gamma  = ctr gamma
\end{code}
\end{myhs}

  Where |Lift : Set -> Set1| lifts an inhabitant of a smaller universe into
a bigger one. The rest of the model is trivial. We define a product of kind |k|
and a sum of kind |k| as lists, and interpret them using |All| and |Any|, respectively.

\begin{myhs}
\begin{code}
Prod SoP : KK -> Set2
Prod  k = List (Field k)
SoP   k = List (Prod k)

interpP holder : forall {k} -> Prod k -> Gamma k -> Set2
interpP as gamma = All (\ alpha -> interpA alpha gamma) as

interpS holder : forall {k} -> Prod k -> Gamma k -> Set2
interpS ps gamma = Any (\ pi -> interpP pi gamma) ps
\end{code}
\end{myhs}
  
  Finally, going full circle and encoding the example shown at the introduction
would look like:

\begin{myhs}
\begin{code}
data IsNat : Set -> Set where
  Prf : Nat -> IsNat Nat

isnatSOP : SoP (KS KZ KZ)
isnatSOP = (Implicit ctr :: Explicit (Var VZ) :: []) :: []
  where
    ctr : Gamma (KS KZ KZ) -> Set1
    ctr (x :: []) = x == Nat
\end{code}
\end{myhs}

  Adding an extra constructor to |Atom| to mark, explicitely, which
are the recursive positions is quite simple. The constructor would have type:

\begin{myhs}
\begin{code}
Rec : Term k k
\end{code}
\end{myhs}

  And we would need one extra parameter of type |interpK k| in the interpretation
functions. Again, as long as we do not take the least fixpoint of this construction,
there is no need for the |Set : Set| axiom.

%option haskell

\section{Explicit Recursion}
\label{sec:recursion}

  Up until now, we have not distinguished recursive positions from regular
fields in our datatypes. This is also the case in |Generic| and |GenericSOP|,
where recursion is \emph{implicit}.
  
  Marking recursion \emph{explicitly} is advantageous but introduces a
more intricate design. It enables one to write combinators exploiting
recursion schemes, such as fold, but it introduces some extra
complexity to the atoms of the universe and one extra parameter to the
interpretation of codes. In fact, some generic operations require this
explicit recursion information.  Such as the definition of diff and
patch~\cite{Lempsink2009,CacciariMiraldo2017},
zippers~\cite{Hinze2003}, and tree regular expressions~\cite{Serrano2016}.

  The technique of marking recursive positions~\cite{Noort2008,Yakushev2009}
starts with expanding the atoms with a new building block:
\begin{myhs}
\begin{code}
data Rec p = Rec p
\end{code}
\end{myhs}
Although isomorphic to |I|, |Rec| serves quite a different purpose.
Nevertheless, the second step is to bubble up one extra parameter
to the interpretation of codes, lifting it to |Star -> Star|. 
The |from| function would then have a type similar to:

\begin{myhs}
\begin{code}
from :: a -> Rep a a
\end{code}
\end{myhs}

Passing |a| as this extra parameter closes the recursive knot. 

Let us now apply the same technique to our scenario. We 
start by extending the |Atom| type with a new constructor:
\begin{myhs}
\begin{code}
data Atom (dtk :: Kind) k where
  dots
  Rec :: Atom dtk dtk
\end{code}
\end{myhs}
The kind of a recursive occurence is exactly the kind of whatever
datatype we are defining. As an example, we can provide a more
informative code for |[]|, where the recursion is explicit:
\begin{myhs}
\begin{code}
type ListCode = P [ P [ ], P [ V0, Rec :@: V0 ] ]
\end{code}
\end{myhs}

The next step is to extend the interpretation of atoms to include this
new construction. As in the case of \citet{Noort2008}, we only tie the
recursive knot at the level of the |GenericNSOP| type class. In the
meantime, |Ty| is extended with a new argument, which declares which
is the type to be used whenever |Rec| is found.
\begin{myhs}
\begin{code}
type family Ty  (dtk :: Kind) (r :: dtk) (tys :: LoT dtk)
                (t :: Atom dtk k) :: k where
  dots
  Ty dtk r tys Rec = r
\end{code}
\end{myhs}
As a consequence, |NA| and |SOPn| also gain a new type parameter for this recursive position.
\begin{myhs}
\begin{code}
data NA (dtk :: Kind) :: dtk -> LoT dtk -> Field dtk -> Star where dots
type SOPn dtk (c :: DataType dtk) (r :: dtk) (tys :: LoT dtk)
  = NS (NP (NA dtk r tys)) c
\end{code}
\end{myhs}
Finally, the updated |GenericNSOP| mandates this recursive position to
be instantiated with the datatype we are describing, tying the
knot. This approach is similar to the |GenericRegular| type class.
\begin{myhs}
\begin{code}
class GenericNSOP dtk (f :: dtk) where
  type Code f :: DataType dtk

  to    ::  ApplyT dtk f tys -> SOPn dtk (Code f) f tys
  from  ::  SSLoT dtk tys
        =>  SOPn dtk (Code f) f tys -> ApplyT dtk f tys
\end{code}
\end{myhs}
Since the constructors in |NA| do not change depending on whether we
have used |Rec| or not to describe the datatype, the instances we
provided for the previous version of |GenericNSOP| keep working in the
version with explicit recursion.

  It is important to note that marking recursive positions explicitly
is still sound, as demonstrated by the Agda model in \Cref{sec:agda}. 
Unfolding this recursion and taking the least fixed point of a type is 
not, however. That is, we cannot write a |Fix| type, in the lines of:

\begin{myhs}
\begin{code}
data Fix f = Fix (f (Fix f))
\end{code}
\end{myhs}

  That is because the interpretation of sums lives in the second
predicative universe (|Set2|), which forces |Fix| to live in |Set2| aswell. 
However, the argument we have to pass to the interpretation of must be 
an inhabitant of |Set1|, hence we cannot feed |Fix f| back into |f|.
This would require the |Set : Set| axiom, breaking consistency.
Hence, just marking the positions is fine, unfolding the recursion
is where we would find problems.


\paragraph{Updating |gfmap|.}  In \Cref{fig:gfmap3} we used an
ancillary |FunctorAtom| type class to describe which fields we could
map over. It is impossible, though, to write an instance of this form:
\begin{myhs}
\begin{code}
instance (FunctorAtom x) => FunctorAtom (Rec :@: x)
\end{code}
\end{myhs}
In fact, |gfmap| defines the operation for the type we are recurring
over, so this instance ought to exist! In order to convince the
compiler, we play the same trick as before: work with |r| as an
independent entity, and only tie the knot at the level of |gfmap|. We
need to pass the function which works on the recursive position as an
additional argument.
\begin{myhs}
\begin{code}
class FunctorAtom r (t :: Atom (Star -> Star) (Star)) where
  gfmapF  ::  (forall x y dot (x -> y) -> r x -> r y)
          ->  (a -> b)
          ->  NA (Star -> Star) r (a :&&: LoT0) t
          ->  NA (Star -> Star) r (b :&&: LoT0) t
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
instance  (FunctorAtom r x)
          => FunctorAtom r (Rec :@: x) where
  gfmapF r f (T x)
    = T (r (unT . gfmapF r f . T atunder @x @r) x)
\end{code}
\end{myhs}
The trick now is to make the |FunctorAtom| constraint used in |All2|
refer to the same |f| as in the code. And to close the loop, when we
call |gfmapF|, we pass |gfmap| itself as the function to execute in
the when |Rec| is found.
\begin{myhs}
\begin{code}
gfmap  ::  (GenericNSOP (Star -> Star) f,
           AllD (FunctorAtom f) (Code f))
       =>  (a -> b) -> f a -> f b
gfmap f  =  dots
  where
    goP Nil          = Nil
    goP (T x :* xs)  = gfmapF gfmap f (T x) :* goP xs
\end{code}
\end{myhs}
This approach makes the definition of |gfmap| self-contained, in
contrast to the definition without explicit recursion, in which a
|Functor| instance needs to be written to make recursion possible.

\subsection{Explicit Recursion and Existentials}
\label{sec:recursionexists}

The combination of existentials
with explicit recursion is not as straightforward as the combination
of constraints from \Cref{sec:constraints} with explicit recursion.
In this section we outline the changes required to bring both
concepts under the same umbrella.

For the language of codes the introduction of |Rec| does not stop
the original implementation from compiling.
But we also need to update the interpretation datatype |NB|, by adding
an additional argument for the recursive position:
\begin{myhs}
\begin{code}
data NB (dtk :: Kind) :: dtk -> LoT dtk -> Branch dtk -> Star where
  Ex  ::  forall ell (t :: ell) (p :: SKind ell) dtk tys r c dot
          NB (ell -> dtk) ? (t :&&: tys) c  -> NB dtk r tys (Exists p c)
  Cr  ::  NP (NA dtk r tys) fs              -> NB dtk r tys (Constr fs)
\end{code}
\end{myhs}
If we do not introduce any new variables -- the case of |Constr| -- we
can pass down to NA the same type for the recursive position. On the other
hand, the case of |Exists| forces the argument to |Ex| to have kind
|ell -> dtk|. But |r| has kind |dtk| instead.

The problem is that we are using the kind |dtk| for two different tasks.
On the one hand, |dtk| fixes the shape of the context |LoT|. On the other
hand, |dtk| specified which is the kind obtained when recursion is performed,
that is, when |Rec| is used as part of an atom. When one uses |Exists|
the additional type should only be introduced in the context, whereas
the recursive positions should stay as they were.

The solution is to decouple this two modes of use of |dtk|. An atom should
take \emph{two} kind arguments: |rtk| specifies the kind of recursive
positions, and |dtk| specifies the kinds in the context.
\begin{myhs}
\begin{code}
data Atom (rtk :: Kind) (dtk :: Kind) k where
  Var    :: TyVar dtk k  ->  Atom rtk dtk k
  Kon    :: k            ->  Atom rtk dtk k
  (:@:)  :: Atom rtk dtk (k1 -> k2) -> Atom rtk dtk k1
                         ->  Atom rtk dtk k2
  Rec    ::                  Atom rtk dtk rtk
\end{code}
\end{myhs}
This change generates a chain reaction of updates (we refer the reader to
\Cref{sec:fullimpl} for the complete code), the most important being in |NB|:
\begin{myhs}
\begin{code}
data  NB (rtk :: Kind) (dtk :: Kind)
      :: rtk -> LoT dtk -> Branch rtk dtk -> Star where
  Ex  ::  forall ell (t :: ell) (p :: SKind ell) rtk dtk r tys c dot
          NB rtk (ell -> dtk) r (t :&&: tys) c
                                    ->  NB rtk dtk r tys (Exists p c)
  Cr  ::  NP (NA rtk dtk r tys) fs  -> NB rtk dtk r tys (Constr fs)
\end{code}
\end{myhs}
Note how \emph{only} the context argument is extended from |dtk| to |ell -> dtk|.
The kind of the recursive position is kept as |rtk|.

The fact that |dtk| and |rtk| coincide before any existential is introduced
is made explicit in the updated definitions of |DataType| and |SOPn|:
\begin{myhs}
\begin{code}
type DataType dtk = [Branch dtk dtk]

type SOPn dtk (c :: DataType dtk) (r :: dtk) (tys :: LoT dtk)
  = NS (NB dtk dtk r tys) c
\end{code}
\end{myhs}
In both cases the single argument which represents the kind of the datatype
to describe is used as kind for recursion and context.

\section{Arity-generic |fmap|}
\label{sec:kmap}

\begin{figure*}
\begin{myhs}
\begin{code}
data Mappings (as :: LoT dtk) (bs :: LoT dtk) where
  MNil   ::                                Mappings LoT0         LoT0
  MCons  :: (a -> b) -> Mappings as bs ->  Mappings (a :&&: as)  (b :&&: bs)
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
class KFunctor dtk (f :: dtk) where
  kmap :: SSLoT dtk bs => Mappings as bs -> ApplyT dtk f as -> ApplyT dtk f bs

  default kmap  ::  (GenericNSOP dtk f, SSLoT dtk bs, AllD KFunctorField (Code f), ISatisfiedD dtk bs (Code f))
                =>  Mappings as bs -> ApplyT dtk f as -> ApplyT dtk f bs
  kmap fs = to . gkmap (Proxy :: Proxy f) fs . from
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
gkmap  ::  forall dtk (f :: dtk) (as :: LoT dtk) (bs :: LoT dtk) dot
           (GenericNSOP dtk f, AllD KFunctorField (Code f), ISatisfiedD dtk bs (Code f))
       =>  Proxy f -> Mappings as bs -> SOPn dtk (Code f) as -> SOPn dtk (Code f) bs
gkmap _ f = goS
  where
    goS :: (AllD KFunctorField xs,  ISatisfiedD k bs xs)  => NS (NB k as) xs -> NS (NB k bs) xs
    goS  (Here   x)    = Here   (goB x)
    goS  (There  x)    = There  (goS x)

    goB :: (AllB KFunctorField xs,  ISatisfiedB k bs xs)  => NB k as xs -> NB k bs xs
    goB  (Cr x)        = Cr (goP x)

    goP :: (AllE KFunctorField xs,  ISatisfiedE k bs xs)  => NP (NA k as) xs -> NP (NA k bs) xs
    goP  Nil           = Nil
    goP  (E x  :* xs)  = kmapf f (E x) :* goP xs
    goP  (I    :* xs)  = I :* goP xs
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
class KFunctorField (t :: Atom dtk Star) where
  kmapf :: Mappings as bs -> NA dtk as (Explicit t) -> NA dtk bs (Explicit t)

instance forall dtk (v :: TyVar dtk Type) dot SForTyVar k v => KFunctorField (Var v) where
  kmapf f (E x) = E (go (styvar @dtk @v) f x)
    where  go ::  forall k (as :: LoT k) (bs :: LoT k) (v :: TyVar k Star) dot STyVar k v -> Mappings as bs -> Ty k as (Var v) -> Ty k bs (Var v)
           go SVZ       (MCons g _)   x  = g x
           go (SVS v')  (MCons _ f')  x  = go v' f' x

instance KFunctorField (Kon t) where
  kmapf f (E x) = E x

instance forall f x dot (KFunctorHead f, KFunctorField x) => KFunctorField (f :@: x) where
  kmapf f (E x)  =  E $ unA0 $ unArg
                 $  kmaph (Proxy :: Proxy f) f (MCons (unE . kmapf f . E atunder @x) MNil)
                 $  Arg $ A0 x
\end{code}
\end{myhs}
\begin{myhs}
\begin{code}
class KFunctorHead (t :: Atom dtk k) where
  kmaph  ::  SSLoT k ts => Proxy t -> Mappings as bs -> Mappings rs ts 
         ->  ApplyT k (Ty dtk as t) rs -> ApplyT k (Ty dtk bs t) ts

instance forall f x dot (KFunctorHead f, KFunctorField x) => KFunctorHead (f :@: x) where
  kmaph _ f r x = unArg $ kmaph (Proxy :: Proxy f) f (MCons (unE . kmapf f . E atunder @x) r) $ Arg x

instance forall k (f :: k) dot (KFunctor k f) => KFunctorHead (Kon f) where
  kmaph _ _ r x = kmap r x
\end{code}
\end{myhs}
\caption{Arity-generic map |kmap| and associated type class |KFunctor|}
\label{fig:kmap}
\end{figure*}

\begin{figure}
\begin{myhs}
\begin{code}
data STyVar k (t :: TyVar k Star) where
  SVZ  ::                STyVar (Star -> k)  VZ
  SVS  :: STyVar k v ->  STyVar (Star -> k)  (VS v)

class SForTyVar k (t :: TyVar k Star) where
  styvar :: STyVar k t
instance SForTyVar (Star -> k) VZ where
  styvar = SVZ
instance SForTyVar k v => SForTyVar (Star -> k) (VS v) where
  styvar = SVS styvar
\end{code}
\end{myhs}
\caption{Auxiliary singleton for |TyVar|}
\label{fig:styvar}
\end{figure}

\begin{figure}
\begin{myhs}
\begin{code}
type family AllD c xs :: Constraint where
  AllD  c (P [])                   =  ()
  AllD  c (x qcolon xs)            =  (AllB c x, AllD c xs)

type family AllB c xs :: Constraint where
  AllB  c (Constr x)               =  AllE c x

type family AllE c xs :: Constraint where
  AllE  c (P [])                   =  ()
  AllE  c (Explicit  x qcolon xs)  =  (c x,  AllE c xs)
  AllE  c (Implicit  x qcolon xs)  =         AllE c xs

type family ISatisfiedD dtk (tys :: LoT dtk) xs :: Constraint where
  ISatisfiedD  dtk tys (P []) =  ()
  ISatisfiedD  dtk tys (x qcolon xs)
    =  (ISatisfiedB dtk tys x, ISatisfied dtk tys xs)

type family ISatisfiedB dtk (tys :: LoT dtk) xs :: Constraint where
  ISatisfiedB  dtk tys (Constr x) =  ISatisfiedE dtk tys x

type family ISatisfiedE dtk (tys :: LoT dtk) xs :: Constraint where
  ISatisfiedE  dtk tys (P []) =  ()
  ISatisfiedE  dtk tys (Implicit  x qcolon xs)  
    =  (Ty dtk tys x,  ISatisfiedE dtk tys xs)
  ISatisfiedE  dtk tys (Explicit  x qcolon xs)
    =                  ISatisfiedE dtk tys xs
\end{code}
\end{myhs}
\caption{Auxiliary type families for arity-generic |fmap|}
\end{figure}

\section{Full Implementation}
\label{sec:fullimpl}

Throughout the paper we have refined the different types and classes involved in our generic programming library. We give the end result as a reference, with support for constraints, existentials, and explicit recursion. \Cref{fig:full1} describes the language of codes, \Cref{fig:full2} the datatypes involved in the interpretation of the codes, \Cref{fig:full3} the |GenericNSOP| type class and ancillary constructions, and \Cref{fig:full4} the conversion between applied types and the evidence-carrying |ApplyT|.

\begin{figure}
\begin{myhs}
\begin{code}
data TyVar (dtk :: Kind) k where
  VZ ::                TyVar (x -> xs) x
  VS :: TyVar xs k ->  TyVar (x -> xs) k

data Atom (rtk :: Kind) (dtk :: Kind) k where
  Var    :: TyVar dtk k  ->  Atom rtk dtk k
  Kon    :: k            ->  Atom rtk dtk k
  (:@:)  :: Atom dtk (k1 -> k2) -> Atom dtk k1
                         ->  Atom dtk k2
  Rec    ::                  Atom rtk dtk rtk

data Field (rtk :: Kind) (dtk :: Kind) where
  Explicit  :: Atom rtk dtk (Star)      -> Field rtk dtk
  Implicit  :: Atom rtk dtk Constraint  -> Field rtk dtk

data SKind (ell :: Kind) = KK

data Branch (rtk :: Kind) (dtk :: Kind) where
  Exists  :: SKind ell -> Branch rtk (ell -> dtk)   -> Branch rtk dtk
  Constr  :: [Field rtk dtk]                        -> Branch rtk dtk

type DataType dtk = [Branch dtk dtk]
\end{code}
\end{myhs}
\caption{Full implementation, part 1: language of codes}
\label{fig:full1}
\end{figure}

\begin{figure*}
\begin{myhs}
\begin{code}
data LoT (dtk :: Kind) where
  LoT0    ::                  LoT (Star)
  (:&&:)  :: k -> LoT ks ->   LoT (k -> ks)

type family Ty (rtk :: Kind) (dtk :: Kind) (r :: rtk) (tys :: LoT dtk) (t :: Atom rtk dtk k) :: k where
  Ty rtk (k -> ks)  r (t :&&: tys)  (Var VZ)      = t
  Ty rtk (k -> ks)  r (t :&&: tys)  (Var (VS v))  = Ty rtk ks r tys (Var v)
  Ty rtk dtk        r tys           (Kon t)       = t
  Ty rtk dtk        r tys           (f :@: x)     = (Ty rtk dtk r tys f) (Ty rtk dtk r tys x)
  Ty rtk dtk        r tys           Rec           = r

data NA (rtk :: Kind) (dtk :: Kind) :: rtk -> LoT dtk -> Field dtk -> Star where
  E ::  forall rtk dtk t r tys dot  { unE ::  Ty rtk dtk r tys t }  ->  NA rtk dtk r tys (Explicit t)
  I ::  forall rtk dtk t r tys dot            Ty rtk dtk r tys t    =>  NA rtk dtk r tys (Implicit t)

data NP :: (k -> Star) -> [k] -> Star where
  Nil  ::                    NP f (P [])
  (:*) :: f x -> NP f xs ->  NP f (x qcolon xs)

data NB (rtk :: Kind) (dtk :: Kind) :: rtk -> LoT dtk -> Branch dtk -> Star where
  Ex  ::  forall ell (t :: ell) (p :: SKind ell) rtk dtk r tys c dot  NB rtk (ell -> dtk) r (t :&&: tys) c  -> NB rtk dtk r tys (Exists p c)
  Cr  ::                                                              NP (NA rtk dtk r tys) fs              -> NB rtk dtk r tys (Constr fs)

data NS :: (k -> Star) -> [k] -> Star where
  Here   :: f k      -> NS f (k qcolon ks)
  There  :: NS f ks  -> NS f (k qcolon ks)

type SOPn (dtk :: Kind) (c :: DataType dtk) (r :: dtk) (tys :: LoT dtk) = NS (NB dtk dtk r tys) c
\end{code}
\end{myhs}
\caption{Full implementation, part 2: interpretation of codes}
\label{fig:full2}
\end{figure*}

\begin{figure}
\begin{myhs}
\begin{code}
data SLoT dtk (tys :: LoT dtk) where
  SLoT0  ::                 SLoT (Star)     LoT0
  SLoTA  ::  SLoT ks ts ->  SLoT (k -> ks)  (t :&&: ts)

class SSLoT k (tys :: LoT k) where
  sslot :: SLoT k tys
instance SSLoT (Star) LoT0 where
  sslot = SLoT0
instance SSLoT ks ts => SSLoT (k -> ks) (t :&&: ts) where
  sslot = SLoTA sslot

data ApplyT k (f :: k) (tys :: LoT k) :: Star where
  A0   :: { unA0   ::  f  }  -> ApplyT (Star)     f  LoT0
  Arg  :: { unArg  ::  ApplyT ks (f t) ts  }
                             -> ApplyT (k -> ks)  f (t :&&: ts)

class GenericNSOP dtk (f :: dtk) where
  type Code f :: DataType dtk
  from  ::  ApplyT dtk f tys -> SOPn dtk (Code f) f tys
  to    ::  SSLoT dtk tys
        =>  SOPn dtk (Code f) f tys -> ApplyT dtk f tys
\end{code}
\end{myhs}
\caption{Full implementation, part 3: |GenericNSOP| type class}
\label{fig:full3}
\end{figure}

\begin{figure}
\vspace{1.9cm}
\begin{myhs}
\begin{code}
type family Apply dtk (f :: dtk) (tys :: LoT dtk) :: Star where
  Apply (Star)     f LoT0         = f
  Apply (k -> ks)  f (t :&&: ts)  = Apply ks (f t) ts

unravel :: ApplyT k f tys -> Apply k f tys
unravel (A0   x) = x
unravel (Arg  x) = unravel x

ravel  ::  forall k f tys dot SSLoT k tys 
       =>  Apply k f tys -> ApplyT k f tys
ravel = go (sslot atunder @tys)
  where
    go  ::  forall k f tys dot SLoT k tys
        ->  Apply k f tys -> ApplyT k f tys
    go SLoT0       x = A0   x
    go (SLoTA ts)  x = Arg  (go ts x)
\end{code}
\end{myhs}
\caption{Full implementation, part 4: utility functions}
\label{fig:full4}
\end{figure}

\subsection{List of Extensions}

For reference, we list here the language extensions that must be enabled
in GHC version 8.4.1.
\begin{itemize}
\item For the core construction we require {\it TypeInType}, {\it GADTs}, {\it DataKinds},
{\it TypeFamilies}, {\it ScopedTypeVariables}; and the following extensions
to type classes: {\it MultiParamTypeClasses}, {\it InstanceSigs},
{\it FlexibleContexts}, and {\it FlexibleInstances}.
\item Support for constraints: |ConstraintKinds|.
\item Support for explicit recursion: |RankNTypes|.
\item To refer to the kind |(Star)| explicitly: |ExplicitNamespaces|.
\end{itemize}
There are also some language extensions whose use is not essential to the
construction, but are required to compile the code as given:
\begin{itemize}
\item |TypeOperators| is required to use |(:@:)|, |(:&&:)|, and |(:*)|,
as constructor names.
\item |TypeApplications| to fix the types of some uses of |T|. We could
have used |Proxy| values instead, but this approach is clearer.
\end{itemize}

\end{document}
